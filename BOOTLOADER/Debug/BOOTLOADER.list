
BOOTLOADER.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001294  08000194  08000194  00010194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08001428  08001428  00020008  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08001428  08001428  00020008  2**0
                  CONTENTS
  4 .ARM          00000000  08001428  08001428  00020008  2**0
                  CONTENTS
  5 .preinit_array 00000000  08001428  08001428  00020008  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08001428  08001428  00011428  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800142c  0800142c  0001142c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000008  20000000  08001430  00020000  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000180  20000008  08001438  00020008  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000188  08001438  00020188  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY
 13 .debug_info   00001a89  00000000  00000000  0002007b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000a25  00000000  00000000  00021b04  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000330  00000000  00000000  00022530  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000248  00000000  00000000  00022860  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000013bc  00000000  00000000  00022aa8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00001cad  00000000  00000000  00023e64  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00006d6a  00000000  00000000  00025b11  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00000abc  00000000  00000000  0002c87c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000055  00000000  00000000  0002d338  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000194 <__do_global_dtors_aux>:
 8000194:	b510      	push	{r4, lr}
 8000196:	4c05      	ldr	r4, [pc, #20]	; (80001ac <__do_global_dtors_aux+0x18>)
 8000198:	7823      	ldrb	r3, [r4, #0]
 800019a:	b933      	cbnz	r3, 80001aa <__do_global_dtors_aux+0x16>
 800019c:	4b04      	ldr	r3, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x1c>)
 800019e:	b113      	cbz	r3, 80001a6 <__do_global_dtors_aux+0x12>
 80001a0:	4804      	ldr	r0, [pc, #16]	; (80001b4 <__do_global_dtors_aux+0x20>)
 80001a2:	f3af 8000 	nop.w
 80001a6:	2301      	movs	r3, #1
 80001a8:	7023      	strb	r3, [r4, #0]
 80001aa:	bd10      	pop	{r4, pc}
 80001ac:	20000008 	.word	0x20000008
 80001b0:	00000000 	.word	0x00000000
 80001b4:	08001410 	.word	0x08001410

080001b8 <frame_dummy>:
 80001b8:	b508      	push	{r3, lr}
 80001ba:	4b03      	ldr	r3, [pc, #12]	; (80001c8 <frame_dummy+0x10>)
 80001bc:	b11b      	cbz	r3, 80001c6 <frame_dummy+0xe>
 80001be:	4903      	ldr	r1, [pc, #12]	; (80001cc <frame_dummy+0x14>)
 80001c0:	4803      	ldr	r0, [pc, #12]	; (80001d0 <frame_dummy+0x18>)
 80001c2:	f3af 8000 	nop.w
 80001c6:	bd08      	pop	{r3, pc}
 80001c8:	00000000 	.word	0x00000000
 80001cc:	2000000c 	.word	0x2000000c
 80001d0:	08001410 	.word	0x08001410

080001d4 <BL_voidJumpToAPP_1>:
/*******************************************************************************************************/
/*                                      Variables                           	                       */

/*******************************************************************************************************/
/*                                      Functions Implementations                                      */
void BL_voidJumpToAPP_1(void){
 80001d4:	b580      	push	{r7, lr}
 80001d6:	b082      	sub	sp, #8
 80001d8:	af00      	add	r7, sp, #0
	/*	stack pointer	*/
	*((volatile u32 *)0xE000ED08)=APP_1_BASE_ADD;
 80001da:	4b07      	ldr	r3, [pc, #28]	; (80001f8 <BL_voidJumpToAPP_1+0x24>)
 80001dc:	4a07      	ldr	r2, [pc, #28]	; (80001fc <BL_voidJumpToAPP_1+0x28>)
 80001de:	601a      	str	r2, [r3, #0]
	/*	Reset Handler function	*/
	u32 main_APP_1= *((volatile u32*)(APP_1_BASE_ADD+4));
 80001e0:	4b07      	ldr	r3, [pc, #28]	; (8000200 <BL_voidJumpToAPP_1+0x2c>)
 80001e2:	681b      	ldr	r3, [r3, #0]
 80001e4:	607b      	str	r3, [r7, #4]
	void (*A1_resetHandler_Address)(void) = (void *)main_APP_1;
 80001e6:	687b      	ldr	r3, [r7, #4]
 80001e8:	603b      	str	r3, [r7, #0]
	A1_resetHandler_Address();
 80001ea:	683b      	ldr	r3, [r7, #0]
 80001ec:	4798      	blx	r3
}
 80001ee:	bf00      	nop
 80001f0:	3708      	adds	r7, #8
 80001f2:	46bd      	mov	sp, r7
 80001f4:	bd80      	pop	{r7, pc}
 80001f6:	bf00      	nop
 80001f8:	e000ed08 	.word	0xe000ed08
 80001fc:	08010000 	.word	0x08010000
 8000200:	08010004 	.word	0x08010004

08000204 <BL_voidJumpToAPP_2>:

void BL_voidJumpToAPP_2(void){
 8000204:	b580      	push	{r7, lr}
 8000206:	b082      	sub	sp, #8
 8000208:	af00      	add	r7, sp, #0
	/*	stack pointer	*/
	*((volatile u32 *)0xE000ED08)=APP_2_BASE_ADD;
 800020a:	4b07      	ldr	r3, [pc, #28]	; (8000228 <BL_voidJumpToAPP_2+0x24>)
 800020c:	4a07      	ldr	r2, [pc, #28]	; (800022c <BL_voidJumpToAPP_2+0x28>)
 800020e:	601a      	str	r2, [r3, #0]
	u32 main_APP_2= *((volatile u32*)(APP_2_BASE_ADD+4));
 8000210:	4b07      	ldr	r3, [pc, #28]	; (8000230 <BL_voidJumpToAPP_2+0x2c>)
 8000212:	681b      	ldr	r3, [r3, #0]
 8000214:	607b      	str	r3, [r7, #4]
	/*	Reset Handler function	*/
	void (*A2_resetHandler_Address)(void) = (void *)main_APP_2;
 8000216:	687b      	ldr	r3, [r7, #4]
 8000218:	603b      	str	r3, [r7, #0]
	A2_resetHandler_Address();
 800021a:	683b      	ldr	r3, [r7, #0]
 800021c:	4798      	blx	r3
}
 800021e:	bf00      	nop
 8000220:	3708      	adds	r7, #8
 8000222:	46bd      	mov	sp, r7
 8000224:	bd80      	pop	{r7, pc}
 8000226:	bf00      	nop
 8000228:	e000ed08 	.word	0xe000ed08
 800022c:	08020000 	.word	0x08020000
 8000230:	08020004 	.word	0x08020004

08000234 <HexParser_u8Ascii2Hex>:

/*******************************************************************************************************/
/*                                      Functions Implementations                                      */
/*******************************************************************************************************/
static u8 HexParser_u8Ascii2Hex(u8 A_u8Ascii)
{
 8000234:	b480      	push	{r7}
 8000236:	b085      	sub	sp, #20
 8000238:	af00      	add	r7, sp, #0
 800023a:	4603      	mov	r3, r0
 800023c:	71fb      	strb	r3, [r7, #7]
	/* local variable that holds the returned value */
	u8 L_u8HexValue = 0;
 800023e:	2300      	movs	r3, #0
 8000240:	73fb      	strb	r3, [r7, #15]

	/* Check if this Ascii value is equivalent to number from 0 to 9 */
	if(A_u8Ascii >= '0' && A_u8Ascii <= '9')
 8000242:	79fb      	ldrb	r3, [r7, #7]
 8000244:	2b2f      	cmp	r3, #47	; 0x2f
 8000246:	d906      	bls.n	8000256 <HexParser_u8Ascii2Hex+0x22>
 8000248:	79fb      	ldrb	r3, [r7, #7]
 800024a:	2b39      	cmp	r3, #57	; 0x39
 800024c:	d803      	bhi.n	8000256 <HexParser_u8Ascii2Hex+0x22>
	{
		L_u8HexValue = A_u8Ascii - '0' ;
 800024e:	79fb      	ldrb	r3, [r7, #7]
 8000250:	3b30      	subs	r3, #48	; 0x30
 8000252:	73fb      	strb	r3, [r7, #15]
 8000254:	e008      	b.n	8000268 <HexParser_u8Ascii2Hex+0x34>
	}
	/* Check if this Ascii value is char A to F */
	else if(A_u8Ascii >= 'A' && A_u8Ascii <='F')
 8000256:	79fb      	ldrb	r3, [r7, #7]
 8000258:	2b40      	cmp	r3, #64	; 0x40
 800025a:	d905      	bls.n	8000268 <HexParser_u8Ascii2Hex+0x34>
 800025c:	79fb      	ldrb	r3, [r7, #7]
 800025e:	2b46      	cmp	r3, #70	; 0x46
 8000260:	d802      	bhi.n	8000268 <HexParser_u8Ascii2Hex+0x34>
	{
		/* 55 to transform A to 10, B to 11 and etc.. */
		L_u8HexValue = A_u8Ascii - 55 ; 
 8000262:	79fb      	ldrb	r3, [r7, #7]
 8000264:	3b37      	subs	r3, #55	; 0x37
 8000266:	73fb      	strb	r3, [r7, #15]
	}
	return L_u8HexValue;
 8000268:	7bfb      	ldrb	r3, [r7, #15]
}
 800026a:	4618      	mov	r0, r3
 800026c:	3714      	adds	r7, #20
 800026e:	46bd      	mov	sp, r7
 8000270:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000274:	4770      	bx	lr
	...

08000278 <HexParser_vParseRecord>:

/*******************************************************************************************************/
void HexParser_vParseRecord(u8*Copy_BufRecord)
{
 8000278:	b580      	push	{r7, lr}
 800027a:	b082      	sub	sp, #8
 800027c:	af00      	add	r7, sp, #0
 800027e:	6078      	str	r0, [r7, #4]
	/* Check on record type */
	switch(Copy_BufRecord[8])
 8000280:	687b      	ldr	r3, [r7, #4]
 8000282:	3308      	adds	r3, #8
 8000284:	781b      	ldrb	r3, [r3, #0]
 8000286:	3b30      	subs	r3, #48	; 0x30
 8000288:	2b05      	cmp	r3, #5
 800028a:	d832      	bhi.n	80002f2 <HexParser_vParseRecord+0x7a>
 800028c:	a201      	add	r2, pc, #4	; (adr r2, 8000294 <HexParser_vParseRecord+0x1c>)
 800028e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000292:	bf00      	nop
 8000294:	080002ad 	.word	0x080002ad
 8000298:	080002f3 	.word	0x080002f3
 800029c:	080002f3 	.word	0x080002f3
 80002a0:	080002f3 	.word	0x080002f3
 80002a4:	080002b5 	.word	0x080002b5
 80002a8:	080002eb 	.word	0x080002eb
	{
	case '0' :

		/* Start parsing the record */
		HexParser_voidParseData(Copy_BufRecord);
 80002ac:	6878      	ldr	r0, [r7, #4]
 80002ae:	f000 f835 	bl	800031c <HexParser_voidParseData>
		break;
 80002b2:	e021      	b.n	80002f8 <HexParser_vParseRecord+0x80>
		/* End of file - Do nothing */
		break;

	case '4':
		/*set high address part*/
		if(UpDate_Flag  == No_APP)
 80002b4:	4b12      	ldr	r3, [pc, #72]	; (8000300 <HexParser_vParseRecord+0x88>)
 80002b6:	681b      	ldr	r3, [r3, #0]
 80002b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80002bc:	d103      	bne.n	80002c6 <HexParser_vParseRecord+0x4e>
		{
			FLASH_BASE_ADDR=0x08010000;
 80002be:	4b11      	ldr	r3, [pc, #68]	; (8000304 <HexParser_vParseRecord+0x8c>)
 80002c0:	4a11      	ldr	r2, [pc, #68]	; (8000308 <HexParser_vParseRecord+0x90>)
 80002c2:	601a      	str	r2, [r3, #0]

		else if (UpDate_Flag  == APP_2_MID )
		{
			FLASH_BASE_ADDR=0x08010000;
		}
		break;
 80002c4:	e017      	b.n	80002f6 <HexParser_vParseRecord+0x7e>
		else if ( UpDate_Flag  == APP_1_MID )
 80002c6:	4b0e      	ldr	r3, [pc, #56]	; (8000300 <HexParser_vParseRecord+0x88>)
 80002c8:	681b      	ldr	r3, [r3, #0]
 80002ca:	4a10      	ldr	r2, [pc, #64]	; (800030c <HexParser_vParseRecord+0x94>)
 80002cc:	4293      	cmp	r3, r2
 80002ce:	d103      	bne.n	80002d8 <HexParser_vParseRecord+0x60>
			FLASH_BASE_ADDR=0x08020000;
 80002d0:	4b0c      	ldr	r3, [pc, #48]	; (8000304 <HexParser_vParseRecord+0x8c>)
 80002d2:	4a0f      	ldr	r2, [pc, #60]	; (8000310 <HexParser_vParseRecord+0x98>)
 80002d4:	601a      	str	r2, [r3, #0]
		break;
 80002d6:	e00e      	b.n	80002f6 <HexParser_vParseRecord+0x7e>
		else if (UpDate_Flag  == APP_2_MID )
 80002d8:	4b09      	ldr	r3, [pc, #36]	; (8000300 <HexParser_vParseRecord+0x88>)
 80002da:	681b      	ldr	r3, [r3, #0]
 80002dc:	4a0d      	ldr	r2, [pc, #52]	; (8000314 <HexParser_vParseRecord+0x9c>)
 80002de:	4293      	cmp	r3, r2
 80002e0:	d109      	bne.n	80002f6 <HexParser_vParseRecord+0x7e>
			FLASH_BASE_ADDR=0x08010000;
 80002e2:	4b08      	ldr	r3, [pc, #32]	; (8000304 <HexParser_vParseRecord+0x8c>)
 80002e4:	4a08      	ldr	r2, [pc, #32]	; (8000308 <HexParser_vParseRecord+0x90>)
 80002e6:	601a      	str	r2, [r3, #0]
		break;
 80002e8:	e005      	b.n	80002f6 <HexParser_vParseRecord+0x7e>

	case '5':
		/* End of file - Do nothing */
		D_5_Flag_lastLine=1;
 80002ea:	4b0b      	ldr	r3, [pc, #44]	; (8000318 <HexParser_vParseRecord+0xa0>)
 80002ec:	2201      	movs	r2, #1
 80002ee:	701a      	strb	r2, [r3, #0]
		break;
 80002f0:	e002      	b.n	80002f8 <HexParser_vParseRecord+0x80>


	default:
		/* Do nothing - defensive programming */
		break;
 80002f2:	bf00      	nop
 80002f4:	e000      	b.n	80002f8 <HexParser_vParseRecord+0x80>
		break;
 80002f6:	bf00      	nop
	}
}
 80002f8:	bf00      	nop
 80002fa:	3708      	adds	r7, #8
 80002fc:	46bd      	mov	sp, r7
 80002fe:	bd80      	pop	{r7, pc}
 8000300:	0800c000 	.word	0x0800c000
 8000304:	20000024 	.word	0x20000024
 8000308:	08010000 	.word	0x08010000
 800030c:	ffffaaaa 	.word	0xffffaaaa
 8000310:	08020000 	.word	0x08020000
 8000314:	ffffbbbb 	.word	0xffffbbbb
 8000318:	200000f0 	.word	0x200000f0

0800031c <HexParser_voidParseData>:

/*******************************************************************************************************/
void HexParser_voidParseData(u8 * A_pu8Data)
{
 800031c:	b580      	push	{r7, lr}
 800031e:	b086      	sub	sp, #24
 8000320:	af00      	add	r7, sp, #0
 8000322:	6078      	str	r0, [r7, #4]

	/* 4 digits for conversion */
	u8 digit0,digit1,digit2,digit3 ;

	/* To hold the address value */
	u32 address = 0;
 8000324:	2300      	movs	r3, #0
 8000326:	613b      	str	r3, [r7, #16]

	/*** Getting the character count ***/

	/* Get the high byte */
	CC_high = HexParser_u8Ascii2Hex(A_pu8Data[1]);
 8000328:	687b      	ldr	r3, [r7, #4]
 800032a:	3301      	adds	r3, #1
 800032c:	781b      	ldrb	r3, [r3, #0]
 800032e:	4618      	mov	r0, r3
 8000330:	f7ff ff80 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000334:	4603      	mov	r3, r0
 8000336:	73fb      	strb	r3, [r7, #15]
	/* Get the low byte */
	CC_low = HexParser_u8Ascii2Hex(A_pu8Data[2]);
 8000338:	687b      	ldr	r3, [r7, #4]
 800033a:	3302      	adds	r3, #2
 800033c:	781b      	ldrb	r3, [r3, #0]
 800033e:	4618      	mov	r0, r3
 8000340:	f7ff ff78 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000344:	4603      	mov	r3, r0
 8000346:	73bb      	strb	r3, [r7, #14]
	/* Get the character count */
	CC = (CC_high<<4)|CC_low ;
 8000348:	7bfb      	ldrb	r3, [r7, #15]
 800034a:	011b      	lsls	r3, r3, #4
 800034c:	b25a      	sxtb	r2, r3
 800034e:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8000352:	4313      	orrs	r3, r2
 8000354:	b25b      	sxtb	r3, r3
 8000356:	737b      	strb	r3, [r7, #13]

	/*** Extracting the address ***/
	digit0 = HexParser_u8Ascii2Hex(A_pu8Data[3]);
 8000358:	687b      	ldr	r3, [r7, #4]
 800035a:	3303      	adds	r3, #3
 800035c:	781b      	ldrb	r3, [r3, #0]
 800035e:	4618      	mov	r0, r3
 8000360:	f7ff ff68 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000364:	4603      	mov	r3, r0
 8000366:	733b      	strb	r3, [r7, #12]
	digit1 = HexParser_u8Ascii2Hex(A_pu8Data[4]);
 8000368:	687b      	ldr	r3, [r7, #4]
 800036a:	3304      	adds	r3, #4
 800036c:	781b      	ldrb	r3, [r3, #0]
 800036e:	4618      	mov	r0, r3
 8000370:	f7ff ff60 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000374:	4603      	mov	r3, r0
 8000376:	75fb      	strb	r3, [r7, #23]
	digit2 = HexParser_u8Ascii2Hex(A_pu8Data[5]);
 8000378:	687b      	ldr	r3, [r7, #4]
 800037a:	3305      	adds	r3, #5
 800037c:	781b      	ldrb	r3, [r3, #0]
 800037e:	4618      	mov	r0, r3
 8000380:	f7ff ff58 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000384:	4603      	mov	r3, r0
 8000386:	72fb      	strb	r3, [r7, #11]
	digit3 = HexParser_u8Ascii2Hex(A_pu8Data[6]);
 8000388:	687b      	ldr	r3, [r7, #4]
 800038a:	3306      	adds	r3, #6
 800038c:	781b      	ldrb	r3, [r3, #0]
 800038e:	4618      	mov	r0, r3
 8000390:	f7ff ff50 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000394:	4603      	mov	r3, r0
 8000396:	72bb      	strb	r3, [r7, #10]


	/* Insert the low address into the least significant 4 bytes */
	address = address & 0xFFFF0000;
 8000398:	693b      	ldr	r3, [r7, #16]
 800039a:	0c1b      	lsrs	r3, r3, #16
 800039c:	041b      	lsls	r3, r3, #16
 800039e:	613b      	str	r3, [r7, #16]
	address = (FLASH_BASE_ADDR) |
			(digit0 << 12)    |
 80003a0:	7b3b      	ldrb	r3, [r7, #12]
 80003a2:	031b      	lsls	r3, r3, #12
 80003a4:	461a      	mov	r2, r3
	address = (FLASH_BASE_ADDR) |
 80003a6:	4b3d      	ldr	r3, [pc, #244]	; (800049c <HexParser_voidParseData+0x180>)
 80003a8:	681b      	ldr	r3, [r3, #0]
 80003aa:	4313      	orrs	r3, r2
			(digit1 << 8 )    |
 80003ac:	7dfa      	ldrb	r2, [r7, #23]
 80003ae:	0212      	lsls	r2, r2, #8
			(digit0 << 12)    |
 80003b0:	4313      	orrs	r3, r2
			(digit2 << 4 )    |
 80003b2:	7afa      	ldrb	r2, [r7, #11]
 80003b4:	0112      	lsls	r2, r2, #4
			(digit1 << 8 )    |
 80003b6:	431a      	orrs	r2, r3
			(digit3 << 0 );
 80003b8:	7abb      	ldrb	r3, [r7, #10]
	address = (FLASH_BASE_ADDR) |
 80003ba:	4313      	orrs	r3, r2
 80003bc:	613b      	str	r3, [r7, #16]

	/*** Extracting the data ***/

	/* Writes 2 bytes per time */		  
	for(u8 i=0; i<(CC/2) ; i++)  //CC/2 step every two byte
 80003be:	2300      	movs	r3, #0
 80003c0:	75bb      	strb	r3, [r7, #22]
 80003c2:	e057      	b.n	8000474 <HexParser_voidParseData+0x158>
	{
		/* Get the first byte */
		digit0 = HexParser_u8Ascii2Hex(A_pu8Data[(4*i)+9]);
 80003c4:	7dbb      	ldrb	r3, [r7, #22]
 80003c6:	009b      	lsls	r3, r3, #2
 80003c8:	3309      	adds	r3, #9
 80003ca:	687a      	ldr	r2, [r7, #4]
 80003cc:	4413      	add	r3, r2
 80003ce:	781b      	ldrb	r3, [r3, #0]
 80003d0:	4618      	mov	r0, r3
 80003d2:	f7ff ff2f 	bl	8000234 <HexParser_u8Ascii2Hex>
 80003d6:	4603      	mov	r3, r0
 80003d8:	733b      	strb	r3, [r7, #12]
		digit1 = HexParser_u8Ascii2Hex(A_pu8Data[(4*i)+10]);
 80003da:	7dbb      	ldrb	r3, [r7, #22]
 80003dc:	009b      	lsls	r3, r3, #2
 80003de:	330a      	adds	r3, #10
 80003e0:	687a      	ldr	r2, [r7, #4]
 80003e2:	4413      	add	r3, r2
 80003e4:	781b      	ldrb	r3, [r3, #0]
 80003e6:	4618      	mov	r0, r3
 80003e8:	f7ff ff24 	bl	8000234 <HexParser_u8Ascii2Hex>
 80003ec:	4603      	mov	r3, r0
 80003ee:	75fb      	strb	r3, [r7, #23]
		/* Get the second byte */
		digit2 = HexParser_u8Ascii2Hex(A_pu8Data[(4*i)+11]);
 80003f0:	7dbb      	ldrb	r3, [r7, #22]
 80003f2:	009b      	lsls	r3, r3, #2
 80003f4:	330b      	adds	r3, #11
 80003f6:	687a      	ldr	r2, [r7, #4]
 80003f8:	4413      	add	r3, r2
 80003fa:	781b      	ldrb	r3, [r3, #0]
 80003fc:	4618      	mov	r0, r3
 80003fe:	f7ff ff19 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000402:	4603      	mov	r3, r0
 8000404:	72fb      	strb	r3, [r7, #11]
		digit3 = HexParser_u8Ascii2Hex(A_pu8Data[(4*i)+12]);
 8000406:	7dbb      	ldrb	r3, [r7, #22]
 8000408:	009b      	lsls	r3, r3, #2
 800040a:	330c      	adds	r3, #12
 800040c:	687a      	ldr	r2, [r7, #4]
 800040e:	4413      	add	r3, r2
 8000410:	781b      	ldrb	r3, [r3, #0]
 8000412:	4618      	mov	r0, r3
 8000414:	f7ff ff0e 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000418:	4603      	mov	r3, r0
 800041a:	72bb      	strb	r3, [r7, #10]

		if(digit0==0 && digit1==1 && digit2==0 && digit3==8){
 800041c:	7b3b      	ldrb	r3, [r7, #12]
 800041e:	2b00      	cmp	r3, #0
 8000420:	d10f      	bne.n	8000442 <HexParser_voidParseData+0x126>
 8000422:	7dfb      	ldrb	r3, [r7, #23]
 8000424:	2b01      	cmp	r3, #1
 8000426:	d10c      	bne.n	8000442 <HexParser_voidParseData+0x126>
 8000428:	7afb      	ldrb	r3, [r7, #11]
 800042a:	2b00      	cmp	r3, #0
 800042c:	d109      	bne.n	8000442 <HexParser_voidParseData+0x126>
 800042e:	7abb      	ldrb	r3, [r7, #10]
 8000430:	2b08      	cmp	r3, #8
 8000432:	d106      	bne.n	8000442 <HexParser_voidParseData+0x126>
			if ( UpDate_Flag == APP_1_MID) {
 8000434:	4b1a      	ldr	r3, [pc, #104]	; (80004a0 <HexParser_voidParseData+0x184>)
 8000436:	681b      	ldr	r3, [r3, #0]
 8000438:	4a1a      	ldr	r2, [pc, #104]	; (80004a4 <HexParser_voidParseData+0x188>)
 800043a:	4293      	cmp	r3, r2
 800043c:	d101      	bne.n	8000442 <HexParser_voidParseData+0x126>
				digit1=2;
 800043e:	2302      	movs	r3, #2
 8000440:	75fb      	strb	r3, [r7, #23]
			}
		}
		DataBuffer[i] = (digit2 << 12) |
 8000442:	7afb      	ldrb	r3, [r7, #11]
 8000444:	031b      	lsls	r3, r3, #12
 8000446:	b21a      	sxth	r2, r3
				(digit3 << 8 ) |
 8000448:	7abb      	ldrb	r3, [r7, #10]
 800044a:	021b      	lsls	r3, r3, #8
		DataBuffer[i] = (digit2 << 12) |
 800044c:	b21b      	sxth	r3, r3
 800044e:	4313      	orrs	r3, r2
 8000450:	b21a      	sxth	r2, r3
				(digit0 << 4 ) |
 8000452:	7b3b      	ldrb	r3, [r7, #12]
 8000454:	011b      	lsls	r3, r3, #4
				(digit3 << 8 ) |
 8000456:	b21b      	sxth	r3, r3
 8000458:	4313      	orrs	r3, r2
 800045a:	b21a      	sxth	r2, r3
				(digit0 << 4 ) |
 800045c:	7dfb      	ldrb	r3, [r7, #23]
 800045e:	b21b      	sxth	r3, r3
 8000460:	4313      	orrs	r3, r2
 8000462:	b21a      	sxth	r2, r3
		DataBuffer[i] = (digit2 << 12) |
 8000464:	7dbb      	ldrb	r3, [r7, #22]
				(digit0 << 4 ) |
 8000466:	b291      	uxth	r1, r2
		DataBuffer[i] = (digit2 << 12) |
 8000468:	4a0f      	ldr	r2, [pc, #60]	; (80004a8 <HexParser_voidParseData+0x18c>)
 800046a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	for(u8 i=0; i<(CC/2) ; i++)  //CC/2 step every two byte
 800046e:	7dbb      	ldrb	r3, [r7, #22]
 8000470:	3301      	adds	r3, #1
 8000472:	75bb      	strb	r3, [r7, #22]
 8000474:	7b7b      	ldrb	r3, [r7, #13]
 8000476:	085b      	lsrs	r3, r3, #1
 8000478:	b2db      	uxtb	r3, r3
 800047a:	7dba      	ldrb	r2, [r7, #22]
 800047c:	429a      	cmp	r2, r3
 800047e:	d3a1      	bcc.n	80003c4 <HexParser_voidParseData+0xa8>
	 * Load the second byte then first byte using MSB first
	 * Example: FE BA should be loaded as BA FE
	 */

	/* Write the data in the flash memory */
	MFMI_voidFlashWrite(address, DataBuffer, CC/2);
 8000480:	7b7b      	ldrb	r3, [r7, #13]
 8000482:	085b      	lsrs	r3, r3, #1
 8000484:	b2db      	uxtb	r3, r3
 8000486:	b29b      	uxth	r3, r3
 8000488:	461a      	mov	r2, r3
 800048a:	4907      	ldr	r1, [pc, #28]	; (80004a8 <HexParser_voidParseData+0x18c>)
 800048c:	6938      	ldr	r0, [r7, #16]
 800048e:	f000 f935 	bl	80006fc <MFMI_voidFlashWrite>
}
 8000492:	bf00      	nop
 8000494:	3718      	adds	r7, #24
 8000496:	46bd      	mov	sp, r7
 8000498:	bd80      	pop	{r7, pc}
 800049a:	bf00      	nop
 800049c:	20000024 	.word	0x20000024
 80004a0:	0800c000 	.word	0x0800c000
 80004a4:	ffffaaaa 	.word	0xffffaaaa
 80004a8:	20000028 	.word	0x20000028

080004ac <HexParser_CheckSumOfData>:

/*******************************************************************************************************/
u8 HexParser_CheckSumOfData (u8 * Copy_u8BufData)
{
 80004ac:	b590      	push	{r4, r7, lr}
 80004ae:	b089      	sub	sp, #36	; 0x24
 80004b0:	af00      	add	r7, sp, #0
 80004b2:	6078      	str	r0, [r7, #4]
	/* local variable */
	u8 CharCount_H_Byte = 0, CharCount_L_Byte = 0 ,CharCount = 0;
 80004b4:	2300      	movs	r3, #0
 80004b6:	75fb      	strb	r3, [r7, #23]
 80004b8:	2300      	movs	r3, #0
 80004ba:	75bb      	strb	r3, [r7, #22]
 80004bc:	2300      	movs	r3, #0
 80004be:	757b      	strb	r3, [r7, #21]
	u8 No_ofRecord_Digits_without_CS_digits = 0;
 80004c0:	2300      	movs	r3, #0
 80004c2:	753b      	strb	r3, [r7, #20]
	u8 Sum_of_Digits_without_CS_digits = 0;
 80004c4:	2300      	movs	r3, #0
 80004c6:	77fb      	strb	r3, [r7, #31]
	int CheckSum = 0;
 80004c8:	2300      	movs	r3, #0
 80004ca:	613b      	str	r3, [r7, #16]
	u8 Check_No_Error;

	/*** Getting the character count ***/

	/* Get the high byte */
	CharCount_H_Byte = HexParser_u8Ascii2Hex(Copy_u8BufData[1]);
 80004cc:	687b      	ldr	r3, [r7, #4]
 80004ce:	3301      	adds	r3, #1
 80004d0:	781b      	ldrb	r3, [r3, #0]
 80004d2:	4618      	mov	r0, r3
 80004d4:	f7ff feae 	bl	8000234 <HexParser_u8Ascii2Hex>
 80004d8:	4603      	mov	r3, r0
 80004da:	75fb      	strb	r3, [r7, #23]
	/* Get the low byte */
	CharCount_L_Byte = HexParser_u8Ascii2Hex(Copy_u8BufData[2]);
 80004dc:	687b      	ldr	r3, [r7, #4]
 80004de:	3302      	adds	r3, #2
 80004e0:	781b      	ldrb	r3, [r3, #0]
 80004e2:	4618      	mov	r0, r3
 80004e4:	f7ff fea6 	bl	8000234 <HexParser_u8Ascii2Hex>
 80004e8:	4603      	mov	r3, r0
 80004ea:	75bb      	strb	r3, [r7, #22]
	/* Get the character count */
	CharCount = (CharCount_H_Byte << 4) | CharCount_L_Byte;
 80004ec:	7dfb      	ldrb	r3, [r7, #23]
 80004ee:	011b      	lsls	r3, r3, #4
 80004f0:	b25a      	sxtb	r2, r3
 80004f2:	f997 3016 	ldrsb.w	r3, [r7, #22]
 80004f6:	4313      	orrs	r3, r2
 80004f8:	b25b      	sxtb	r3, r3
 80004fa:	757b      	strb	r3, [r7, #21]
     Type_digit      = 2 digit
     so we add 8 to sum of data digits
	 */

	/* Calculate number of digits */
	No_ofRecord_Digits_without_CS_digits = (CharCount * 2) + 8;
 80004fc:	7d7b      	ldrb	r3, [r7, #21]
 80004fe:	3304      	adds	r3, #4
 8000500:	b2db      	uxtb	r3, r3
 8000502:	005b      	lsls	r3, r3, #1
 8000504:	753b      	strb	r3, [r7, #20]
	/*
	  Start from 1 to neglect the ':'
	  Increment by 1 bytes "2 digit"
	 */

	for (int i = 1 ;i < No_ofRecord_Digits_without_CS_digits; i+=2)
 8000506:	2301      	movs	r3, #1
 8000508:	61bb      	str	r3, [r7, #24]
 800050a:	e019      	b.n	8000540 <HexParser_CheckSumOfData+0x94>
	{
		/* Accumulate the sum byte by byte */
		Sum_of_Digits_without_CS_digits += ( HexParser_u8Ascii2Hex(Copy_u8BufData[i]) << 4) |HexParser_u8Ascii2Hex((Copy_u8BufData[i+1]));
 800050c:	69bb      	ldr	r3, [r7, #24]
 800050e:	687a      	ldr	r2, [r7, #4]
 8000510:	4413      	add	r3, r2
 8000512:	781b      	ldrb	r3, [r3, #0]
 8000514:	4618      	mov	r0, r3
 8000516:	f7ff fe8d 	bl	8000234 <HexParser_u8Ascii2Hex>
 800051a:	4603      	mov	r3, r0
 800051c:	011c      	lsls	r4, r3, #4
 800051e:	69bb      	ldr	r3, [r7, #24]
 8000520:	3301      	adds	r3, #1
 8000522:	687a      	ldr	r2, [r7, #4]
 8000524:	4413      	add	r3, r2
 8000526:	781b      	ldrb	r3, [r3, #0]
 8000528:	4618      	mov	r0, r3
 800052a:	f7ff fe83 	bl	8000234 <HexParser_u8Ascii2Hex>
 800052e:	4603      	mov	r3, r0
 8000530:	4323      	orrs	r3, r4
 8000532:	b2da      	uxtb	r2, r3
 8000534:	7ffb      	ldrb	r3, [r7, #31]
 8000536:	4413      	add	r3, r2
 8000538:	77fb      	strb	r3, [r7, #31]
	for (int i = 1 ;i < No_ofRecord_Digits_without_CS_digits; i+=2)
 800053a:	69bb      	ldr	r3, [r7, #24]
 800053c:	3302      	adds	r3, #2
 800053e:	61bb      	str	r3, [r7, #24]
 8000540:	7d3b      	ldrb	r3, [r7, #20]
 8000542:	69ba      	ldr	r2, [r7, #24]
 8000544:	429a      	cmp	r2, r3
 8000546:	dbe1      	blt.n	800050c <HexParser_CheckSumOfData+0x60>
	  Checksum is the 2s-complement of the sum of the number of bytes, plus the address plus the data
	  Add up the number of bytes, the address and all the data and discard any carry to give 8-bit total
	  Then invert each digit to give 1s-complement by XOR with 0xFF then add 1 to get the 2s-complement
	 */

	Sum_of_Digits_without_CS_digits = (((Sum_of_Digits_without_CS_digits ^ 0xFF)) + 1);
 8000548:	7ffb      	ldrb	r3, [r7, #31]
 800054a:	425b      	negs	r3, r3
 800054c:	77fb      	strb	r3, [r7, #31]

	/*   Get the checkSum byte from Record */

	int CheckSum_HByte = HexParser_u8Ascii2Hex(Copy_u8BufData[No_ofRecord_Digits_without_CS_digits+1]);
 800054e:	7d3b      	ldrb	r3, [r7, #20]
 8000550:	3301      	adds	r3, #1
 8000552:	687a      	ldr	r2, [r7, #4]
 8000554:	4413      	add	r3, r2
 8000556:	781b      	ldrb	r3, [r3, #0]
 8000558:	4618      	mov	r0, r3
 800055a:	f7ff fe6b 	bl	8000234 <HexParser_u8Ascii2Hex>
 800055e:	4603      	mov	r3, r0
 8000560:	60fb      	str	r3, [r7, #12]
	int CheckSum_LByte = HexParser_u8Ascii2Hex(Copy_u8BufData[No_ofRecord_Digits_without_CS_digits+2]);
 8000562:	7d3b      	ldrb	r3, [r7, #20]
 8000564:	3302      	adds	r3, #2
 8000566:	687a      	ldr	r2, [r7, #4]
 8000568:	4413      	add	r3, r2
 800056a:	781b      	ldrb	r3, [r3, #0]
 800056c:	4618      	mov	r0, r3
 800056e:	f7ff fe61 	bl	8000234 <HexParser_u8Ascii2Hex>
 8000572:	4603      	mov	r3, r0
 8000574:	60bb      	str	r3, [r7, #8]
	CheckSum = ( CheckSum_HByte << 4) | CheckSum_LByte ;
 8000576:	68fb      	ldr	r3, [r7, #12]
 8000578:	011b      	lsls	r3, r3, #4
 800057a:	68ba      	ldr	r2, [r7, #8]
 800057c:	4313      	orrs	r3, r2
 800057e:	613b      	str	r3, [r7, #16]

	/* Compare between Calculated checksum and checksum in record*/
	if ((CheckSum & 0xFF) == (Sum_of_Digits_without_CS_digits& 0xFF))
 8000580:	693b      	ldr	r3, [r7, #16]
 8000582:	b2da      	uxtb	r2, r3
 8000584:	7ffb      	ldrb	r3, [r7, #31]
 8000586:	429a      	cmp	r2, r3
 8000588:	d102      	bne.n	8000590 <HexParser_CheckSumOfData+0xe4>
	{
		Check_No_Error = No_ERROR;
 800058a:	2301      	movs	r3, #1
 800058c:	77bb      	strb	r3, [r7, #30]
 800058e:	e001      	b.n	8000594 <HexParser_CheckSumOfData+0xe8>
	}
	else
	{
		Check_No_Error = ERROR;
 8000590:	2300      	movs	r3, #0
 8000592:	77bb      	strb	r3, [r7, #30]
	}
	return Check_No_Error;
 8000594:	7fbb      	ldrb	r3, [r7, #30]

}
 8000596:	4618      	mov	r0, r3
 8000598:	3724      	adds	r7, #36	; 0x24
 800059a:	46bd      	mov	sp, r7
 800059c:	bd90      	pop	{r4, r7, pc}
	...

080005a0 <EXTI0_IRQHandler>:

}
/*******************************************************************************************************/

void EXTI0_IRQHandler(void)								
{
 80005a0:	b580      	push	{r7, lr}
 80005a2:	af00      	add	r7, sp, #0
	EXTI0_CallBack();
 80005a4:	4b05      	ldr	r3, [pc, #20]	; (80005bc <EXTI0_IRQHandler+0x1c>)
 80005a6:	681b      	ldr	r3, [r3, #0]
 80005a8:	4798      	blx	r3
	SET_BIT( EXTI_Ptr->PR , LINE_0 );					// With Out That It Will Do INT Alaways
 80005aa:	4b05      	ldr	r3, [pc, #20]	; (80005c0 <EXTI0_IRQHandler+0x20>)
 80005ac:	695b      	ldr	r3, [r3, #20]
 80005ae:	4a04      	ldr	r2, [pc, #16]	; (80005c0 <EXTI0_IRQHandler+0x20>)
 80005b0:	f043 0301 	orr.w	r3, r3, #1
 80005b4:	6153      	str	r3, [r2, #20]
}
 80005b6:	bf00      	nop
 80005b8:	bd80      	pop	{r7, pc}
 80005ba:	bf00      	nop
 80005bc:	200000f4 	.word	0x200000f4
 80005c0:	40013c00 	.word	0x40013c00

080005c4 <EXTI1_IRQHandler>:

/*******************************************************************************************************/
void EXTI1_IRQHandler(void)
{
 80005c4:	b580      	push	{r7, lr}
 80005c6:	af00      	add	r7, sp, #0
	EXTI1_CallBack();
 80005c8:	4b05      	ldr	r3, [pc, #20]	; (80005e0 <EXTI1_IRQHandler+0x1c>)
 80005ca:	681b      	ldr	r3, [r3, #0]
 80005cc:	4798      	blx	r3
	SET_BIT( EXTI_Ptr->PR , LINE_1 );					// With Out That It Will Do INT Alaways
 80005ce:	4b05      	ldr	r3, [pc, #20]	; (80005e4 <EXTI1_IRQHandler+0x20>)
 80005d0:	695b      	ldr	r3, [r3, #20]
 80005d2:	4a04      	ldr	r2, [pc, #16]	; (80005e4 <EXTI1_IRQHandler+0x20>)
 80005d4:	f043 0302 	orr.w	r3, r3, #2
 80005d8:	6153      	str	r3, [r2, #20]
}
 80005da:	bf00      	nop
 80005dc:	bd80      	pop	{r7, pc}
 80005de:	bf00      	nop
 80005e0:	200000f8 	.word	0x200000f8
 80005e4:	40013c00 	.word	0x40013c00

080005e8 <EXTI2_IRQHandler>:

/*******************************************************************************************************/
void EXTI2_IRQHandler(void)								
{
 80005e8:	b580      	push	{r7, lr}
 80005ea:	af00      	add	r7, sp, #0
	EXTI2_CallBack();
 80005ec:	4b05      	ldr	r3, [pc, #20]	; (8000604 <EXTI2_IRQHandler+0x1c>)
 80005ee:	681b      	ldr	r3, [r3, #0]
 80005f0:	4798      	blx	r3
	SET_BIT( EXTI_Ptr->PR , LINE_2 );					// With Out That It Will Do INT Alaways
 80005f2:	4b05      	ldr	r3, [pc, #20]	; (8000608 <EXTI2_IRQHandler+0x20>)
 80005f4:	695b      	ldr	r3, [r3, #20]
 80005f6:	4a04      	ldr	r2, [pc, #16]	; (8000608 <EXTI2_IRQHandler+0x20>)
 80005f8:	f043 0304 	orr.w	r3, r3, #4
 80005fc:	6153      	str	r3, [r2, #20]
}
 80005fe:	bf00      	nop
 8000600:	bd80      	pop	{r7, pc}
 8000602:	bf00      	nop
 8000604:	200000fc 	.word	0x200000fc
 8000608:	40013c00 	.word	0x40013c00

0800060c <EXTI3_IRQHandler>:

/*******************************************************************************************************/
void EXTI3_IRQHandler(void)
{
 800060c:	b580      	push	{r7, lr}
 800060e:	af00      	add	r7, sp, #0
	EXTI3_CallBack();
 8000610:	4b05      	ldr	r3, [pc, #20]	; (8000628 <EXTI3_IRQHandler+0x1c>)
 8000612:	681b      	ldr	r3, [r3, #0]
 8000614:	4798      	blx	r3
	SET_BIT( EXTI_Ptr->PR , LINE_3 );					// With Out That It Will Do INT Alaways
 8000616:	4b05      	ldr	r3, [pc, #20]	; (800062c <EXTI3_IRQHandler+0x20>)
 8000618:	695b      	ldr	r3, [r3, #20]
 800061a:	4a04      	ldr	r2, [pc, #16]	; (800062c <EXTI3_IRQHandler+0x20>)
 800061c:	f043 0308 	orr.w	r3, r3, #8
 8000620:	6153      	str	r3, [r2, #20]
}
 8000622:	bf00      	nop
 8000624:	bd80      	pop	{r7, pc}
 8000626:	bf00      	nop
 8000628:	20000100 	.word	0x20000100
 800062c:	40013c00 	.word	0x40013c00

08000630 <EXTI4_IRQHandler>:

/*******************************************************************************************************/
void EXTI4_IRQHandler(void)
{
 8000630:	b580      	push	{r7, lr}
 8000632:	af00      	add	r7, sp, #0
	EXTI4_CallBack();
 8000634:	4b05      	ldr	r3, [pc, #20]	; (800064c <EXTI4_IRQHandler+0x1c>)
 8000636:	681b      	ldr	r3, [r3, #0]
 8000638:	4798      	blx	r3
	SET_BIT( EXTI_Ptr->PR , LINE_4 );					// With Out That It Will Do INT Alaways
 800063a:	4b05      	ldr	r3, [pc, #20]	; (8000650 <EXTI4_IRQHandler+0x20>)
 800063c:	695b      	ldr	r3, [r3, #20]
 800063e:	4a04      	ldr	r2, [pc, #16]	; (8000650 <EXTI4_IRQHandler+0x20>)
 8000640:	f043 0310 	orr.w	r3, r3, #16
 8000644:	6153      	str	r3, [r2, #20]
}
 8000646:	bf00      	nop
 8000648:	bd80      	pop	{r7, pc}
 800064a:	bf00      	nop
 800064c:	20000104 	.word	0x20000104
 8000650:	40013c00 	.word	0x40013c00

08000654 <MFMI_voidSectorErase>:
	CLR_BIT(FMI->CR, 2);
}

/*******************************************************************************************************/
void MFMI_voidSectorErase(u8 A_u8SectorNo)
{
 8000654:	b480      	push	{r7}
 8000656:	b083      	sub	sp, #12
 8000658:	af00      	add	r7, sp, #0
 800065a:	4603      	mov	r3, r0
 800065c:	71fb      	strb	r3, [r7, #7]
	/* 1- Wait if Flash is Busy (BSY) */
	while(GET_BIT(FMI->SR, 16) == 1){}
 800065e:	bf00      	nop
 8000660:	4b23      	ldr	r3, [pc, #140]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 8000662:	68db      	ldr	r3, [r3, #12]
 8000664:	0c1b      	lsrs	r3, r3, #16
 8000666:	f003 0301 	and.w	r3, r3, #1
 800066a:	2b01      	cmp	r3, #1
 800066c:	d0f8      	beq.n	8000660 <MFMI_voidSectorErase+0xc>
	/* 2- Unlock Flash Register using KEYR */
	if(GET_BIT(FMI->CR, 31) == 1)
 800066e:	4b20      	ldr	r3, [pc, #128]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 8000670:	691b      	ldr	r3, [r3, #16]
 8000672:	0fdb      	lsrs	r3, r3, #31
 8000674:	f003 0301 	and.w	r3, r3, #1
 8000678:	2b01      	cmp	r3, #1
 800067a:	d105      	bne.n	8000688 <MFMI_voidSectorErase+0x34>
	{
		FMI->KEYR = FMI_KEY1 ;
 800067c:	4b1c      	ldr	r3, [pc, #112]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 800067e:	4a1d      	ldr	r2, [pc, #116]	; (80006f4 <MFMI_voidSectorErase+0xa0>)
 8000680:	605a      	str	r2, [r3, #4]
		FMI->KEYR = FMI_KEY2 ;
 8000682:	4b1b      	ldr	r3, [pc, #108]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 8000684:	4a1c      	ldr	r2, [pc, #112]	; (80006f8 <MFMI_voidSectorErase+0xa4>)
 8000686:	605a      	str	r2, [r3, #4]
	}

	/* 3- select Sector Number to erase */
	FMI->CR &=~((u32)(0b1111<<3));
 8000688:	4b19      	ldr	r3, [pc, #100]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 800068a:	691b      	ldr	r3, [r3, #16]
 800068c:	4a18      	ldr	r2, [pc, #96]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 800068e:	f023 0378 	bic.w	r3, r3, #120	; 0x78
 8000692:	6113      	str	r3, [r2, #16]
	FMI->CR |= (A_u8SectorNo <<3);
 8000694:	4b16      	ldr	r3, [pc, #88]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 8000696:	691b      	ldr	r3, [r3, #16]
 8000698:	79fa      	ldrb	r2, [r7, #7]
 800069a:	00d2      	lsls	r2, r2, #3
 800069c:	4611      	mov	r1, r2
 800069e:	4a14      	ldr	r2, [pc, #80]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006a0:	430b      	orrs	r3, r1
 80006a2:	6113      	str	r3, [r2, #16]

	/* 4- Select Erase operation */
	SET_BIT(FMI->CR, 1);
 80006a4:	4b12      	ldr	r3, [pc, #72]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006a6:	691b      	ldr	r3, [r3, #16]
 80006a8:	4a11      	ldr	r2, [pc, #68]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006aa:	f043 0302 	orr.w	r3, r3, #2
 80006ae:	6113      	str	r3, [r2, #16]
	/* 5- Start erase operation  */
	SET_BIT(FMI->CR, 16);
 80006b0:	4b0f      	ldr	r3, [pc, #60]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006b2:	691b      	ldr	r3, [r3, #16]
 80006b4:	4a0e      	ldr	r2, [pc, #56]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80006ba:	6113      	str	r3, [r2, #16]
	/* 6- wait for Busy Flag    */
	while(GET_BIT(FMI->SR, 16) == 1){}
 80006bc:	bf00      	nop
 80006be:	4b0c      	ldr	r3, [pc, #48]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006c0:	68db      	ldr	r3, [r3, #12]
 80006c2:	0c1b      	lsrs	r3, r3, #16
 80006c4:	f003 0301 	and.w	r3, r3, #1
 80006c8:	2b01      	cmp	r3, #1
 80006ca:	d0f8      	beq.n	80006be <MFMI_voidSectorErase+0x6a>
	/* 7- Clear EOP flag   */
	SET_BIT(FMI->SR, 0);
 80006cc:	4b08      	ldr	r3, [pc, #32]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006ce:	68db      	ldr	r3, [r3, #12]
 80006d0:	4a07      	ldr	r2, [pc, #28]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006d2:	f043 0301 	orr.w	r3, r3, #1
 80006d6:	60d3      	str	r3, [r2, #12]

	/* 8- DeSelect Erase Operation (reverse of step 4) */
	CLR_BIT(FMI->CR, 1);
 80006d8:	4b05      	ldr	r3, [pc, #20]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006da:	691b      	ldr	r3, [r3, #16]
 80006dc:	4a04      	ldr	r2, [pc, #16]	; (80006f0 <MFMI_voidSectorErase+0x9c>)
 80006de:	f023 0302 	bic.w	r3, r3, #2
 80006e2:	6113      	str	r3, [r2, #16]
}
 80006e4:	bf00      	nop
 80006e6:	370c      	adds	r7, #12
 80006e8:	46bd      	mov	sp, r7
 80006ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80006ee:	4770      	bx	lr
 80006f0:	40023c00 	.word	0x40023c00
 80006f4:	45670123 	.word	0x45670123
 80006f8:	cdef89ab 	.word	0xcdef89ab

080006fc <MFMI_voidFlashWrite>:

/*******************************************************************************************************/
void MFMI_voidFlashWrite(u32 A_u32Address, u16* A_pu16Data, u16  A_u16Length)
{
 80006fc:	b480      	push	{r7}
 80006fe:	b087      	sub	sp, #28
 8000700:	af00      	add	r7, sp, #0
 8000702:	60f8      	str	r0, [r7, #12]
 8000704:	60b9      	str	r1, [r7, #8]
 8000706:	4613      	mov	r3, r2
 8000708:	80fb      	strh	r3, [r7, #6]
	/* 1- Wait if Flash is Busy (BSY) */
	while(GET_BIT(FMI->SR, 16) == 1){}
 800070a:	bf00      	nop
 800070c:	4b29      	ldr	r3, [pc, #164]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800070e:	68db      	ldr	r3, [r3, #12]
 8000710:	0c1b      	lsrs	r3, r3, #16
 8000712:	f003 0301 	and.w	r3, r3, #1
 8000716:	2b01      	cmp	r3, #1
 8000718:	d0f8      	beq.n	800070c <MFMI_voidFlashWrite+0x10>
	/* 2- Unlock Flash Register using KEYR */
	if(GET_BIT(FMI->CR, 31) == 1)
 800071a:	4b26      	ldr	r3, [pc, #152]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800071c:	691b      	ldr	r3, [r3, #16]
 800071e:	0fdb      	lsrs	r3, r3, #31
 8000720:	f003 0301 	and.w	r3, r3, #1
 8000724:	2b01      	cmp	r3, #1
 8000726:	d105      	bne.n	8000734 <MFMI_voidFlashWrite+0x38>
	{
		FMI->KEYR = FMI_KEY1 ;
 8000728:	4b22      	ldr	r3, [pc, #136]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800072a:	4a23      	ldr	r2, [pc, #140]	; (80007b8 <MFMI_voidFlashWrite+0xbc>)
 800072c:	605a      	str	r2, [r3, #4]
		FMI->KEYR = FMI_KEY2 ;
 800072e:	4b21      	ldr	r3, [pc, #132]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000730:	4a22      	ldr	r2, [pc, #136]	; (80007bc <MFMI_voidFlashWrite+0xc0>)
 8000732:	605a      	str	r2, [r3, #4]
	}

	/* 3- select element size (PSIZE)  */
	FMI->CR &=~((u32)(0b11<<8)) ;
 8000734:	4b1f      	ldr	r3, [pc, #124]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000736:	691b      	ldr	r3, [r3, #16]
 8000738:	4a1e      	ldr	r2, [pc, #120]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800073a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800073e:	6113      	str	r3, [r2, #16]
	FMI->CR |= (Program_size<<8);
 8000740:	4b1c      	ldr	r3, [pc, #112]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000742:	691b      	ldr	r3, [r3, #16]
 8000744:	4a1b      	ldr	r2, [pc, #108]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000746:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800074a:	6113      	str	r3, [r2, #16]

	/* 4- Activate Programming Mode (PG bit) */
	SET_BIT(FMI->CR, 0);
 800074c:	4b19      	ldr	r3, [pc, #100]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800074e:	691b      	ldr	r3, [r3, #16]
 8000750:	4a18      	ldr	r2, [pc, #96]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000752:	f043 0301 	orr.w	r3, r3, #1
 8000756:	6113      	str	r3, [r2, #16]

	/* 5- Write Data Array on Flash address */
	for(u16 i=0; i<A_u16Length; i++)
 8000758:	2300      	movs	r3, #0
 800075a:	82fb      	strh	r3, [r7, #22]
 800075c:	e01a      	b.n	8000794 <MFMI_voidFlashWrite+0x98>
	{
		*((volatile u16*)A_u32Address) = A_pu16Data[i];
 800075e:	8afb      	ldrh	r3, [r7, #22]
 8000760:	005b      	lsls	r3, r3, #1
 8000762:	68ba      	ldr	r2, [r7, #8]
 8000764:	441a      	add	r2, r3
 8000766:	68fb      	ldr	r3, [r7, #12]
 8000768:	8812      	ldrh	r2, [r2, #0]
 800076a:	801a      	strh	r2, [r3, #0]
		A_u32Address += 2 ;//2 locations if u used 16 mode
 800076c:	68fb      	ldr	r3, [r7, #12]
 800076e:	3302      	adds	r3, #2
 8000770:	60fb      	str	r3, [r7, #12]

		/* 6- wait for Busy Flag    */
		while(GET_BIT(FMI->SR, 16) == 1){}
 8000772:	bf00      	nop
 8000774:	4b0f      	ldr	r3, [pc, #60]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000776:	68db      	ldr	r3, [r3, #12]
 8000778:	0c1b      	lsrs	r3, r3, #16
 800077a:	f003 0301 	and.w	r3, r3, #1
 800077e:	2b01      	cmp	r3, #1
 8000780:	d0f8      	beq.n	8000774 <MFMI_voidFlashWrite+0x78>
		/* 7- Clear EOP flag   */
		SET_BIT(FMI->SR, 0);
 8000782:	4b0c      	ldr	r3, [pc, #48]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000784:	68db      	ldr	r3, [r3, #12]
 8000786:	4a0b      	ldr	r2, [pc, #44]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 8000788:	f043 0301 	orr.w	r3, r3, #1
 800078c:	60d3      	str	r3, [r2, #12]
	for(u16 i=0; i<A_u16Length; i++)
 800078e:	8afb      	ldrh	r3, [r7, #22]
 8000790:	3301      	adds	r3, #1
 8000792:	82fb      	strh	r3, [r7, #22]
 8000794:	8afa      	ldrh	r2, [r7, #22]
 8000796:	88fb      	ldrh	r3, [r7, #6]
 8000798:	429a      	cmp	r2, r3
 800079a:	d3e0      	bcc.n	800075e <MFMI_voidFlashWrite+0x62>
	}
	/* 8- deactivate programming mode */
	CLR_BIT(FMI->CR, 0);
 800079c:	4b05      	ldr	r3, [pc, #20]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 800079e:	691b      	ldr	r3, [r3, #16]
 80007a0:	4a04      	ldr	r2, [pc, #16]	; (80007b4 <MFMI_voidFlashWrite+0xb8>)
 80007a2:	f023 0301 	bic.w	r3, r3, #1
 80007a6:	6113      	str	r3, [r2, #16]
}
 80007a8:	bf00      	nop
 80007aa:	371c      	adds	r7, #28
 80007ac:	46bd      	mov	sp, r7
 80007ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007b2:	4770      	bx	lr
 80007b4:	40023c00 	.word	0x40023c00
 80007b8:	45670123 	.word	0x45670123
 80007bc:	cdef89ab 	.word	0xcdef89ab

080007c0 <MGPIO_voidSetPinMode>:
#include "MGPIO_interface.h"
#include "MGPIO_config.h"
/*******************************************************************************************************/
/*                                      Functions Implementations                                      */
/*******************************************************************************************************/
void MGPIO_voidSetPinMode(u8 Copy_u8PortName ,u8 Copy_u8PinNum ,u8 Copy_u8Mode  ){
 80007c0:	b480      	push	{r7}
 80007c2:	b083      	sub	sp, #12
 80007c4:	af00      	add	r7, sp, #0
 80007c6:	4603      	mov	r3, r0
 80007c8:	71fb      	strb	r3, [r7, #7]
 80007ca:	460b      	mov	r3, r1
 80007cc:	71bb      	strb	r3, [r7, #6]
 80007ce:	4613      	mov	r3, r2
 80007d0:	717b      	strb	r3, [r7, #5]
	
	switch(Copy_u8PortName)
 80007d2:	79fb      	ldrb	r3, [r7, #7]
 80007d4:	2b05      	cmp	r3, #5
 80007d6:	d857      	bhi.n	8000888 <MGPIO_voidSetPinMode+0xc8>
 80007d8:	a201      	add	r2, pc, #4	; (adr r2, 80007e0 <MGPIO_voidSetPinMode+0x20>)
 80007da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80007de:	bf00      	nop
 80007e0:	080007f9 	.word	0x080007f9
 80007e4:	08000811 	.word	0x08000811
 80007e8:	08000829 	.word	0x08000829
 80007ec:	08000841 	.word	0x08000841
 80007f0:	08000859 	.word	0x08000859
 80007f4:	08000871 	.word	0x08000871
	{
	  case GPIOA_PORT : MGPIOA->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 80007f8:	4b27      	ldr	r3, [pc, #156]	; (8000898 <MGPIO_voidSetPinMode+0xd8>)
 80007fa:	681b      	ldr	r3, [r3, #0]
 80007fc:	7979      	ldrb	r1, [r7, #5]
 80007fe:	79ba      	ldrb	r2, [r7, #6]
 8000800:	0052      	lsls	r2, r2, #1
 8000802:	fa01 f202 	lsl.w	r2, r1, r2
 8000806:	4611      	mov	r1, r2
 8000808:	4a23      	ldr	r2, [pc, #140]	; (8000898 <MGPIO_voidSetPinMode+0xd8>)
 800080a:	430b      	orrs	r3, r1
 800080c:	6013      	str	r3, [r2, #0]
 800080e:	e03c      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  case GPIOB_PORT : MGPIOB->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 8000810:	4b22      	ldr	r3, [pc, #136]	; (800089c <MGPIO_voidSetPinMode+0xdc>)
 8000812:	681b      	ldr	r3, [r3, #0]
 8000814:	7979      	ldrb	r1, [r7, #5]
 8000816:	79ba      	ldrb	r2, [r7, #6]
 8000818:	0052      	lsls	r2, r2, #1
 800081a:	fa01 f202 	lsl.w	r2, r1, r2
 800081e:	4611      	mov	r1, r2
 8000820:	4a1e      	ldr	r2, [pc, #120]	; (800089c <MGPIO_voidSetPinMode+0xdc>)
 8000822:	430b      	orrs	r3, r1
 8000824:	6013      	str	r3, [r2, #0]
 8000826:	e030      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  case GPIOC_PORT : MGPIOC->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 8000828:	4b1d      	ldr	r3, [pc, #116]	; (80008a0 <MGPIO_voidSetPinMode+0xe0>)
 800082a:	681b      	ldr	r3, [r3, #0]
 800082c:	7979      	ldrb	r1, [r7, #5]
 800082e:	79ba      	ldrb	r2, [r7, #6]
 8000830:	0052      	lsls	r2, r2, #1
 8000832:	fa01 f202 	lsl.w	r2, r1, r2
 8000836:	4611      	mov	r1, r2
 8000838:	4a19      	ldr	r2, [pc, #100]	; (80008a0 <MGPIO_voidSetPinMode+0xe0>)
 800083a:	430b      	orrs	r3, r1
 800083c:	6013      	str	r3, [r2, #0]
 800083e:	e024      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  case GPIOD_PORT : MGPIOD->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 8000840:	4b18      	ldr	r3, [pc, #96]	; (80008a4 <MGPIO_voidSetPinMode+0xe4>)
 8000842:	681b      	ldr	r3, [r3, #0]
 8000844:	7979      	ldrb	r1, [r7, #5]
 8000846:	79ba      	ldrb	r2, [r7, #6]
 8000848:	0052      	lsls	r2, r2, #1
 800084a:	fa01 f202 	lsl.w	r2, r1, r2
 800084e:	4611      	mov	r1, r2
 8000850:	4a14      	ldr	r2, [pc, #80]	; (80008a4 <MGPIO_voidSetPinMode+0xe4>)
 8000852:	430b      	orrs	r3, r1
 8000854:	6013      	str	r3, [r2, #0]
 8000856:	e018      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  case GPIOE_PORT : MGPIOE->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 8000858:	4b13      	ldr	r3, [pc, #76]	; (80008a8 <MGPIO_voidSetPinMode+0xe8>)
 800085a:	681b      	ldr	r3, [r3, #0]
 800085c:	7979      	ldrb	r1, [r7, #5]
 800085e:	79ba      	ldrb	r2, [r7, #6]
 8000860:	0052      	lsls	r2, r2, #1
 8000862:	fa01 f202 	lsl.w	r2, r1, r2
 8000866:	4611      	mov	r1, r2
 8000868:	4a0f      	ldr	r2, [pc, #60]	; (80008a8 <MGPIO_voidSetPinMode+0xe8>)
 800086a:	430b      	orrs	r3, r1
 800086c:	6013      	str	r3, [r2, #0]
 800086e:	e00c      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  case GPIOH_PORT : MGPIOH->MODER |= (u32) ( Copy_u8Mode << ( 2U* Copy_u8PinNum )) ; break;
 8000870:	4b0e      	ldr	r3, [pc, #56]	; (80008ac <MGPIO_voidSetPinMode+0xec>)
 8000872:	681b      	ldr	r3, [r3, #0]
 8000874:	7979      	ldrb	r1, [r7, #5]
 8000876:	79ba      	ldrb	r2, [r7, #6]
 8000878:	0052      	lsls	r2, r2, #1
 800087a:	fa01 f202 	lsl.w	r2, r1, r2
 800087e:	4611      	mov	r1, r2
 8000880:	4a0a      	ldr	r2, [pc, #40]	; (80008ac <MGPIO_voidSetPinMode+0xec>)
 8000882:	430b      	orrs	r3, r1
 8000884:	6013      	str	r3, [r2, #0]
 8000886:	e000      	b.n	800088a <MGPIO_voidSetPinMode+0xca>
	  default : /*ERROR*/ break ;
 8000888:	bf00      	nop
    }
}
 800088a:	bf00      	nop
 800088c:	370c      	adds	r7, #12
 800088e:	46bd      	mov	sp, r7
 8000890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000894:	4770      	bx	lr
 8000896:	bf00      	nop
 8000898:	40020000 	.word	0x40020000
 800089c:	40020400 	.word	0x40020400
 80008a0:	40020800 	.word	0x40020800
 80008a4:	40020c00 	.word	0x40020c00
 80008a8:	40021000 	.word	0x40021000
 80008ac:	40021c00 	.word	0x40021c00

080008b0 <MGPIO_voidSetPinAltFn>:
		}
	}
}
/*******************************************************************************************************/
void MGPIO_voidSetPinAltFn( u8 Copy_u8PortNum ,u8 Copy_u8PinNum, u8 Copy_u8ALF )
{
 80008b0:	b480      	push	{r7}
 80008b2:	b083      	sub	sp, #12
 80008b4:	af00      	add	r7, sp, #0
 80008b6:	4603      	mov	r3, r0
 80008b8:	71fb      	strb	r3, [r7, #7]
 80008ba:	460b      	mov	r3, r1
 80008bc:	71bb      	strb	r3, [r7, #6]
 80008be:	4613      	mov	r3, r2
 80008c0:	717b      	strb	r3, [r7, #5]
	if(Copy_u8PinNum <=7U)
 80008c2:	79bb      	ldrb	r3, [r7, #6]
 80008c4:	2b07      	cmp	r3, #7
 80008c6:	d85b      	bhi.n	8000980 <MGPIO_voidSetPinAltFn+0xd0>
	{
		/* Alf pins 0:7 */
		switch(Copy_u8PortNum )
 80008c8:	79fb      	ldrb	r3, [r7, #7]
 80008ca:	2b05      	cmp	r3, #5
 80008cc:	f200 80be 	bhi.w	8000a4c <MGPIO_voidSetPinAltFn+0x19c>
 80008d0:	a201      	add	r2, pc, #4	; (adr r2, 80008d8 <MGPIO_voidSetPinAltFn+0x28>)
 80008d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80008d6:	bf00      	nop
 80008d8:	080008f1 	.word	0x080008f1
 80008dc:	08000909 	.word	0x08000909
 80008e0:	08000921 	.word	0x08000921
 80008e4:	08000939 	.word	0x08000939
 80008e8:	08000951 	.word	0x08000951
 80008ec:	08000969 	.word	0x08000969
		{
			 case GPIOA_PORT  : MGPIOA->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 80008f0:	4b5b      	ldr	r3, [pc, #364]	; (8000a60 <MGPIO_voidSetPinAltFn+0x1b0>)
 80008f2:	6a1b      	ldr	r3, [r3, #32]
 80008f4:	7979      	ldrb	r1, [r7, #5]
 80008f6:	79ba      	ldrb	r2, [r7, #6]
 80008f8:	0092      	lsls	r2, r2, #2
 80008fa:	fa01 f202 	lsl.w	r2, r1, r2
 80008fe:	4611      	mov	r1, r2
 8000900:	4a57      	ldr	r2, [pc, #348]	; (8000a60 <MGPIO_voidSetPinAltFn+0x1b0>)
 8000902:	430b      	orrs	r3, r1
 8000904:	6213      	str	r3, [r2, #32]
 8000906:	e0a4      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOB_PORT  : MGPIOB->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 8000908:	4b56      	ldr	r3, [pc, #344]	; (8000a64 <MGPIO_voidSetPinAltFn+0x1b4>)
 800090a:	6a1b      	ldr	r3, [r3, #32]
 800090c:	7979      	ldrb	r1, [r7, #5]
 800090e:	79ba      	ldrb	r2, [r7, #6]
 8000910:	0092      	lsls	r2, r2, #2
 8000912:	fa01 f202 	lsl.w	r2, r1, r2
 8000916:	4611      	mov	r1, r2
 8000918:	4a52      	ldr	r2, [pc, #328]	; (8000a64 <MGPIO_voidSetPinAltFn+0x1b4>)
 800091a:	430b      	orrs	r3, r1
 800091c:	6213      	str	r3, [r2, #32]
 800091e:	e098      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOC_PORT  : MGPIOC->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 8000920:	4b51      	ldr	r3, [pc, #324]	; (8000a68 <MGPIO_voidSetPinAltFn+0x1b8>)
 8000922:	6a1b      	ldr	r3, [r3, #32]
 8000924:	7979      	ldrb	r1, [r7, #5]
 8000926:	79ba      	ldrb	r2, [r7, #6]
 8000928:	0092      	lsls	r2, r2, #2
 800092a:	fa01 f202 	lsl.w	r2, r1, r2
 800092e:	4611      	mov	r1, r2
 8000930:	4a4d      	ldr	r2, [pc, #308]	; (8000a68 <MGPIO_voidSetPinAltFn+0x1b8>)
 8000932:	430b      	orrs	r3, r1
 8000934:	6213      	str	r3, [r2, #32]
 8000936:	e08c      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOD_PORT  : MGPIOD->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 8000938:	4b4c      	ldr	r3, [pc, #304]	; (8000a6c <MGPIO_voidSetPinAltFn+0x1bc>)
 800093a:	6a1b      	ldr	r3, [r3, #32]
 800093c:	7979      	ldrb	r1, [r7, #5]
 800093e:	79ba      	ldrb	r2, [r7, #6]
 8000940:	0092      	lsls	r2, r2, #2
 8000942:	fa01 f202 	lsl.w	r2, r1, r2
 8000946:	4611      	mov	r1, r2
 8000948:	4a48      	ldr	r2, [pc, #288]	; (8000a6c <MGPIO_voidSetPinAltFn+0x1bc>)
 800094a:	430b      	orrs	r3, r1
 800094c:	6213      	str	r3, [r2, #32]
 800094e:	e080      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOE_PORT  : MGPIOE->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 8000950:	4b47      	ldr	r3, [pc, #284]	; (8000a70 <MGPIO_voidSetPinAltFn+0x1c0>)
 8000952:	6a1b      	ldr	r3, [r3, #32]
 8000954:	7979      	ldrb	r1, [r7, #5]
 8000956:	79ba      	ldrb	r2, [r7, #6]
 8000958:	0092      	lsls	r2, r2, #2
 800095a:	fa01 f202 	lsl.w	r2, r1, r2
 800095e:	4611      	mov	r1, r2
 8000960:	4a43      	ldr	r2, [pc, #268]	; (8000a70 <MGPIO_voidSetPinAltFn+0x1c0>)
 8000962:	430b      	orrs	r3, r1
 8000964:	6213      	str	r3, [r2, #32]
 8000966:	e074      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOH_PORT  : MGPIOH->AFRL |=(u32)(Copy_u8ALF <<(4U* Copy_u8PinNum)); break ;
 8000968:	4b42      	ldr	r3, [pc, #264]	; (8000a74 <MGPIO_voidSetPinAltFn+0x1c4>)
 800096a:	6a1b      	ldr	r3, [r3, #32]
 800096c:	7979      	ldrb	r1, [r7, #5]
 800096e:	79ba      	ldrb	r2, [r7, #6]
 8000970:	0092      	lsls	r2, r2, #2
 8000972:	fa01 f202 	lsl.w	r2, r1, r2
 8000976:	4611      	mov	r1, r2
 8000978:	4a3e      	ldr	r2, [pc, #248]	; (8000a74 <MGPIO_voidSetPinAltFn+0x1c4>)
 800097a:	430b      	orrs	r3, r1
 800097c:	6213      	str	r3, [r2, #32]
 800097e:	e068      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
		
	}
	/* Alf pins 8:15 */
	else
	{
	switch(Copy_u8PortNum )
 8000980:	79fb      	ldrb	r3, [r7, #7]
 8000982:	2b05      	cmp	r3, #5
 8000984:	d864      	bhi.n	8000a50 <MGPIO_voidSetPinAltFn+0x1a0>
 8000986:	a201      	add	r2, pc, #4	; (adr r2, 800098c <MGPIO_voidSetPinAltFn+0xdc>)
 8000988:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800098c:	080009a5 	.word	0x080009a5
 8000990:	080009c1 	.word	0x080009c1
 8000994:	080009dd 	.word	0x080009dd
 8000998:	080009f9 	.word	0x080009f9
 800099c:	08000a15 	.word	0x08000a15
 80009a0:	08000a31 	.word	0x08000a31
		{
			 case GPIOA_PORT  : MGPIOA->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U))); break ;
 80009a4:	4b2e      	ldr	r3, [pc, #184]	; (8000a60 <MGPIO_voidSetPinAltFn+0x1b0>)
 80009a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80009a8:	7979      	ldrb	r1, [r7, #5]
 80009aa:	79ba      	ldrb	r2, [r7, #6]
 80009ac:	f002 0207 	and.w	r2, r2, #7
 80009b0:	0092      	lsls	r2, r2, #2
 80009b2:	fa01 f202 	lsl.w	r2, r1, r2
 80009b6:	4611      	mov	r1, r2
 80009b8:	4a29      	ldr	r2, [pc, #164]	; (8000a60 <MGPIO_voidSetPinAltFn+0x1b0>)
 80009ba:	430b      	orrs	r3, r1
 80009bc:	6253      	str	r3, [r2, #36]	; 0x24
 80009be:	e048      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOB_PORT  : MGPIOB->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U ))); break ;
 80009c0:	4b28      	ldr	r3, [pc, #160]	; (8000a64 <MGPIO_voidSetPinAltFn+0x1b4>)
 80009c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80009c4:	7979      	ldrb	r1, [r7, #5]
 80009c6:	79ba      	ldrb	r2, [r7, #6]
 80009c8:	f002 0207 	and.w	r2, r2, #7
 80009cc:	0092      	lsls	r2, r2, #2
 80009ce:	fa01 f202 	lsl.w	r2, r1, r2
 80009d2:	4611      	mov	r1, r2
 80009d4:	4a23      	ldr	r2, [pc, #140]	; (8000a64 <MGPIO_voidSetPinAltFn+0x1b4>)
 80009d6:	430b      	orrs	r3, r1
 80009d8:	6253      	str	r3, [r2, #36]	; 0x24
 80009da:	e03a      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOC_PORT  : MGPIOC->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U))); break ;
 80009dc:	4b22      	ldr	r3, [pc, #136]	; (8000a68 <MGPIO_voidSetPinAltFn+0x1b8>)
 80009de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80009e0:	7979      	ldrb	r1, [r7, #5]
 80009e2:	79ba      	ldrb	r2, [r7, #6]
 80009e4:	f002 0207 	and.w	r2, r2, #7
 80009e8:	0092      	lsls	r2, r2, #2
 80009ea:	fa01 f202 	lsl.w	r2, r1, r2
 80009ee:	4611      	mov	r1, r2
 80009f0:	4a1d      	ldr	r2, [pc, #116]	; (8000a68 <MGPIO_voidSetPinAltFn+0x1b8>)
 80009f2:	430b      	orrs	r3, r1
 80009f4:	6253      	str	r3, [r2, #36]	; 0x24
 80009f6:	e02c      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOD_PORT  : MGPIOD->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U ))); break ;
 80009f8:	4b1c      	ldr	r3, [pc, #112]	; (8000a6c <MGPIO_voidSetPinAltFn+0x1bc>)
 80009fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80009fc:	7979      	ldrb	r1, [r7, #5]
 80009fe:	79ba      	ldrb	r2, [r7, #6]
 8000a00:	f002 0207 	and.w	r2, r2, #7
 8000a04:	0092      	lsls	r2, r2, #2
 8000a06:	fa01 f202 	lsl.w	r2, r1, r2
 8000a0a:	4611      	mov	r1, r2
 8000a0c:	4a17      	ldr	r2, [pc, #92]	; (8000a6c <MGPIO_voidSetPinAltFn+0x1bc>)
 8000a0e:	430b      	orrs	r3, r1
 8000a10:	6253      	str	r3, [r2, #36]	; 0x24
 8000a12:	e01e      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOE_PORT  : MGPIOE->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U ))); break ;
 8000a14:	4b16      	ldr	r3, [pc, #88]	; (8000a70 <MGPIO_voidSetPinAltFn+0x1c0>)
 8000a16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a18:	7979      	ldrb	r1, [r7, #5]
 8000a1a:	79ba      	ldrb	r2, [r7, #6]
 8000a1c:	f002 0207 	and.w	r2, r2, #7
 8000a20:	0092      	lsls	r2, r2, #2
 8000a22:	fa01 f202 	lsl.w	r2, r1, r2
 8000a26:	4611      	mov	r1, r2
 8000a28:	4a11      	ldr	r2, [pc, #68]	; (8000a70 <MGPIO_voidSetPinAltFn+0x1c0>)
 8000a2a:	430b      	orrs	r3, r1
 8000a2c:	6253      	str	r3, [r2, #36]	; 0x24
 8000a2e:	e010      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 case GPIOH_PORT  : MGPIOH->AFRH |=(u32)(Copy_u8ALF <<(4U* (Copy_u8PinNum % 8U))); break ;
 8000a30:	4b10      	ldr	r3, [pc, #64]	; (8000a74 <MGPIO_voidSetPinAltFn+0x1c4>)
 8000a32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a34:	7979      	ldrb	r1, [r7, #5]
 8000a36:	79ba      	ldrb	r2, [r7, #6]
 8000a38:	f002 0207 	and.w	r2, r2, #7
 8000a3c:	0092      	lsls	r2, r2, #2
 8000a3e:	fa01 f202 	lsl.w	r2, r1, r2
 8000a42:	4611      	mov	r1, r2
 8000a44:	4a0b      	ldr	r2, [pc, #44]	; (8000a74 <MGPIO_voidSetPinAltFn+0x1c4>)
 8000a46:	430b      	orrs	r3, r1
 8000a48:	6253      	str	r3, [r2, #36]	; 0x24
 8000a4a:	e002      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 default : break ;
 8000a4c:	bf00      	nop
 8000a4e:	e000      	b.n	8000a52 <MGPIO_voidSetPinAltFn+0x1a2>
			 default : break ;
 8000a50:	bf00      	nop
		
		
	}

	
}
 8000a52:	bf00      	nop
 8000a54:	370c      	adds	r7, #12
 8000a56:	46bd      	mov	sp, r7
 8000a58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a5c:	4770      	bx	lr
 8000a5e:	bf00      	nop
 8000a60:	40020000 	.word	0x40020000
 8000a64:	40020400 	.word	0x40020400
 8000a68:	40020800 	.word	0x40020800
 8000a6c:	40020c00 	.word	0x40020c00
 8000a70:	40021000 	.word	0x40021000
 8000a74:	40021c00 	.word	0x40021c00

08000a78 <MRCC_voidEnablePeripheralClock>:
/*******************************************************************************************************/
/*                                      Functions Implementations                                      */
/*******************************************************************************************************/

void MRCC_voidEnablePeripheralClock(BusName_t BusName , u8 Copy_u8PerNum )
{
 8000a78:	b480      	push	{r7}
 8000a7a:	b083      	sub	sp, #12
 8000a7c:	af00      	add	r7, sp, #0
 8000a7e:	4603      	mov	r3, r0
 8000a80:	460a      	mov	r2, r1
 8000a82:	71fb      	strb	r3, [r7, #7]
 8000a84:	4613      	mov	r3, r2
 8000a86:	71bb      	strb	r3, [r7, #6]
	
	switch(BusName)
 8000a88:	79fb      	ldrb	r3, [r7, #7]
 8000a8a:	2b03      	cmp	r3, #3
 8000a8c:	d836      	bhi.n	8000afc <MRCC_voidEnablePeripheralClock+0x84>
 8000a8e:	a201      	add	r2, pc, #4	; (adr r2, 8000a94 <MRCC_voidEnablePeripheralClock+0x1c>)
 8000a90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000a94:	08000aa5 	.word	0x08000aa5
 8000a98:	08000abb 	.word	0x08000abb
 8000a9c:	08000ad1 	.word	0x08000ad1
 8000aa0:	08000ae7 	.word	0x08000ae7
	{
		case AHB1_BUS:  SET_BIT(RCC_AHB1ENR,Copy_u8PerNum );         break ;
 8000aa4:	4b19      	ldr	r3, [pc, #100]	; (8000b0c <MRCC_voidEnablePeripheralClock+0x94>)
 8000aa6:	681b      	ldr	r3, [r3, #0]
 8000aa8:	79ba      	ldrb	r2, [r7, #6]
 8000aaa:	2101      	movs	r1, #1
 8000aac:	fa01 f202 	lsl.w	r2, r1, r2
 8000ab0:	4611      	mov	r1, r2
 8000ab2:	4a16      	ldr	r2, [pc, #88]	; (8000b0c <MRCC_voidEnablePeripheralClock+0x94>)
 8000ab4:	430b      	orrs	r3, r1
 8000ab6:	6013      	str	r3, [r2, #0]
 8000ab8:	e021      	b.n	8000afe <MRCC_voidEnablePeripheralClock+0x86>
		case AHB2_BUS:  SET_BIT(RCC_AHB2ENR,Copy_u8PerNum );         break ;
 8000aba:	4b15      	ldr	r3, [pc, #84]	; (8000b10 <MRCC_voidEnablePeripheralClock+0x98>)
 8000abc:	681b      	ldr	r3, [r3, #0]
 8000abe:	79ba      	ldrb	r2, [r7, #6]
 8000ac0:	2101      	movs	r1, #1
 8000ac2:	fa01 f202 	lsl.w	r2, r1, r2
 8000ac6:	4611      	mov	r1, r2
 8000ac8:	4a11      	ldr	r2, [pc, #68]	; (8000b10 <MRCC_voidEnablePeripheralClock+0x98>)
 8000aca:	430b      	orrs	r3, r1
 8000acc:	6013      	str	r3, [r2, #0]
 8000ace:	e016      	b.n	8000afe <MRCC_voidEnablePeripheralClock+0x86>
		case APB1_BUS:  SET_BIT(RCC_APB1ENR,Copy_u8PerNum );         break ;
 8000ad0:	4b10      	ldr	r3, [pc, #64]	; (8000b14 <MRCC_voidEnablePeripheralClock+0x9c>)
 8000ad2:	681b      	ldr	r3, [r3, #0]
 8000ad4:	79ba      	ldrb	r2, [r7, #6]
 8000ad6:	2101      	movs	r1, #1
 8000ad8:	fa01 f202 	lsl.w	r2, r1, r2
 8000adc:	4611      	mov	r1, r2
 8000ade:	4a0d      	ldr	r2, [pc, #52]	; (8000b14 <MRCC_voidEnablePeripheralClock+0x9c>)
 8000ae0:	430b      	orrs	r3, r1
 8000ae2:	6013      	str	r3, [r2, #0]
 8000ae4:	e00b      	b.n	8000afe <MRCC_voidEnablePeripheralClock+0x86>
		case APB2_BUS:  SET_BIT(RCC_APB2ENR,Copy_u8PerNum );         break ;
 8000ae6:	4b0c      	ldr	r3, [pc, #48]	; (8000b18 <MRCC_voidEnablePeripheralClock+0xa0>)
 8000ae8:	681b      	ldr	r3, [r3, #0]
 8000aea:	79ba      	ldrb	r2, [r7, #6]
 8000aec:	2101      	movs	r1, #1
 8000aee:	fa01 f202 	lsl.w	r2, r1, r2
 8000af2:	4611      	mov	r1, r2
 8000af4:	4a08      	ldr	r2, [pc, #32]	; (8000b18 <MRCC_voidEnablePeripheralClock+0xa0>)
 8000af6:	430b      	orrs	r3, r1
 8000af8:	6013      	str	r3, [r2, #0]
 8000afa:	e000      	b.n	8000afe <MRCC_voidEnablePeripheralClock+0x86>
		default :     /*   ERROR   */          break ;
 8000afc:	bf00      	nop
		
	}
}
 8000afe:	bf00      	nop
 8000b00:	370c      	adds	r7, #12
 8000b02:	46bd      	mov	sp, r7
 8000b04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b08:	4770      	bx	lr
 8000b0a:	bf00      	nop
 8000b0c:	40023830 	.word	0x40023830
 8000b10:	40023834 	.word	0x40023834
 8000b14:	40023840 	.word	0x40023840
 8000b18:	40023844 	.word	0x40023844

08000b1c <MRCC_voidDisablePeripheralClock>:
/*******************************************************************************************************/


void MRCC_voidDisablePeripheralClock(BusName_t BusName , u8 Copy_u8PerNum )
{
 8000b1c:	b480      	push	{r7}
 8000b1e:	b083      	sub	sp, #12
 8000b20:	af00      	add	r7, sp, #0
 8000b22:	4603      	mov	r3, r0
 8000b24:	460a      	mov	r2, r1
 8000b26:	71fb      	strb	r3, [r7, #7]
 8000b28:	4613      	mov	r3, r2
 8000b2a:	71bb      	strb	r3, [r7, #6]
	switch(BusName)
 8000b2c:	79fb      	ldrb	r3, [r7, #7]
 8000b2e:	2b03      	cmp	r3, #3
 8000b30:	d83a      	bhi.n	8000ba8 <MRCC_voidDisablePeripheralClock+0x8c>
 8000b32:	a201      	add	r2, pc, #4	; (adr r2, 8000b38 <MRCC_voidDisablePeripheralClock+0x1c>)
 8000b34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000b38:	08000b49 	.word	0x08000b49
 8000b3c:	08000b61 	.word	0x08000b61
 8000b40:	08000b79 	.word	0x08000b79
 8000b44:	08000b91 	.word	0x08000b91
	{
		case AHB1_BUS:  CLR_BIT(RCC_AHB1ENR,Copy_u8PerNum );         break ;
 8000b48:	4b1b      	ldr	r3, [pc, #108]	; (8000bb8 <MRCC_voidDisablePeripheralClock+0x9c>)
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	79ba      	ldrb	r2, [r7, #6]
 8000b4e:	2101      	movs	r1, #1
 8000b50:	fa01 f202 	lsl.w	r2, r1, r2
 8000b54:	43d2      	mvns	r2, r2
 8000b56:	4611      	mov	r1, r2
 8000b58:	4a17      	ldr	r2, [pc, #92]	; (8000bb8 <MRCC_voidDisablePeripheralClock+0x9c>)
 8000b5a:	400b      	ands	r3, r1
 8000b5c:	6013      	str	r3, [r2, #0]
 8000b5e:	e024      	b.n	8000baa <MRCC_voidDisablePeripheralClock+0x8e>
		case AHB2_BUS:  CLR_BIT(RCC_AHB2ENR,Copy_u8PerNum );         break ;
 8000b60:	4b16      	ldr	r3, [pc, #88]	; (8000bbc <MRCC_voidDisablePeripheralClock+0xa0>)
 8000b62:	681b      	ldr	r3, [r3, #0]
 8000b64:	79ba      	ldrb	r2, [r7, #6]
 8000b66:	2101      	movs	r1, #1
 8000b68:	fa01 f202 	lsl.w	r2, r1, r2
 8000b6c:	43d2      	mvns	r2, r2
 8000b6e:	4611      	mov	r1, r2
 8000b70:	4a12      	ldr	r2, [pc, #72]	; (8000bbc <MRCC_voidDisablePeripheralClock+0xa0>)
 8000b72:	400b      	ands	r3, r1
 8000b74:	6013      	str	r3, [r2, #0]
 8000b76:	e018      	b.n	8000baa <MRCC_voidDisablePeripheralClock+0x8e>
		case APB1_BUS:  CLR_BIT(RCC_APB1ENR,Copy_u8PerNum );         break ;
 8000b78:	4b11      	ldr	r3, [pc, #68]	; (8000bc0 <MRCC_voidDisablePeripheralClock+0xa4>)
 8000b7a:	681b      	ldr	r3, [r3, #0]
 8000b7c:	79ba      	ldrb	r2, [r7, #6]
 8000b7e:	2101      	movs	r1, #1
 8000b80:	fa01 f202 	lsl.w	r2, r1, r2
 8000b84:	43d2      	mvns	r2, r2
 8000b86:	4611      	mov	r1, r2
 8000b88:	4a0d      	ldr	r2, [pc, #52]	; (8000bc0 <MRCC_voidDisablePeripheralClock+0xa4>)
 8000b8a:	400b      	ands	r3, r1
 8000b8c:	6013      	str	r3, [r2, #0]
 8000b8e:	e00c      	b.n	8000baa <MRCC_voidDisablePeripheralClock+0x8e>
		case APB2_BUS:  CLR_BIT(RCC_APB2ENR,Copy_u8PerNum );         break ;
 8000b90:	4b0c      	ldr	r3, [pc, #48]	; (8000bc4 <MRCC_voidDisablePeripheralClock+0xa8>)
 8000b92:	681b      	ldr	r3, [r3, #0]
 8000b94:	79ba      	ldrb	r2, [r7, #6]
 8000b96:	2101      	movs	r1, #1
 8000b98:	fa01 f202 	lsl.w	r2, r1, r2
 8000b9c:	43d2      	mvns	r2, r2
 8000b9e:	4611      	mov	r1, r2
 8000ba0:	4a08      	ldr	r2, [pc, #32]	; (8000bc4 <MRCC_voidDisablePeripheralClock+0xa8>)
 8000ba2:	400b      	ands	r3, r1
 8000ba4:	6013      	str	r3, [r2, #0]
 8000ba6:	e000      	b.n	8000baa <MRCC_voidDisablePeripheralClock+0x8e>
		default :     /* ERROR */          break ;
 8000ba8:	bf00      	nop
		
	}
}
 8000baa:	bf00      	nop
 8000bac:	370c      	adds	r7, #12
 8000bae:	46bd      	mov	sp, r7
 8000bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bb4:	4770      	bx	lr
 8000bb6:	bf00      	nop
 8000bb8:	40023830 	.word	0x40023830
 8000bbc:	40023834 	.word	0x40023834
 8000bc0:	40023840 	.word	0x40023840
 8000bc4:	40023844 	.word	0x40023844

08000bc8 <MRCC_voidInitSystemClk>:
	
}
/*******************************************************************************************************/

void MRCC_voidInitSystemClk(void)
{
 8000bc8:	b480      	push	{r7}
 8000bca:	af00      	add	r7, sp, #0
	/********** HSI **********/
#if CLKSRC == HSI 
	/* 1- EN HSI */
	SET_BIT(MRCC->CR , 0U);
 8000bcc:	4b0b      	ldr	r3, [pc, #44]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000bce:	681b      	ldr	r3, [r3, #0]
 8000bd0:	4a0a      	ldr	r2, [pc, #40]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000bd2:	f043 0301 	orr.w	r3, r3, #1
 8000bd6:	6013      	str	r3, [r2, #0]
	/* 2- CLK SYS --> HSI */
	CLR_BIT(MRCC->CFGR, 0U);
 8000bd8:	4b08      	ldr	r3, [pc, #32]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000bda:	689b      	ldr	r3, [r3, #8]
 8000bdc:	4a07      	ldr	r2, [pc, #28]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000bde:	f023 0301 	bic.w	r3, r3, #1
 8000be2:	6093      	str	r3, [r2, #8]
	CLR_BIT(MRCC->CFGR, 1U);
 8000be4:	4b05      	ldr	r3, [pc, #20]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000be6:	689b      	ldr	r3, [r3, #8]
 8000be8:	4a04      	ldr	r2, [pc, #16]	; (8000bfc <MRCC_voidInitSystemClk+0x34>)
 8000bea:	f023 0302 	bic.w	r3, r3, #2
 8000bee:	6093      	str	r3, [r2, #8]
/****************************************************/

#else 
/* Error*/
#endif // The End Of Big IF	
}
 8000bf0:	bf00      	nop
 8000bf2:	46bd      	mov	sp, r7
 8000bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bf8:	4770      	bx	lr
 8000bfa:	bf00      	nop
 8000bfc:	40023800 	.word	0x40023800

08000c00 <MSTK_voidInit>:
static void (* MSTK_CallBack) (void) = NULL;
static u8	MSTK_u8ModeOfInterval;

/*******************************************************************************************************/
/*                                      01- MSTK_voidInit                                              */
void MSTK_voidInit( void ){
 8000c00:	b480      	push	{r7}
 8000c02:	af00      	add	r7, sp, #0

	#if CLK_SOURCE_CONFIG == PROCCESOR_CLK_AHB
	SET_BIT(MSTK->CTRL , CLKSOURCE);
	#elif CLK_SOURCE_CONFIG == PROCCESOR_CLK_AHB_DIV8
	CLR_BIT(MSTK->CTRL , CLKSOURCE);
 8000c04:	4b05      	ldr	r3, [pc, #20]	; (8000c1c <MSTK_voidInit+0x1c>)
 8000c06:	681b      	ldr	r3, [r3, #0]
 8000c08:	4a04      	ldr	r2, [pc, #16]	; (8000c1c <MSTK_voidInit+0x1c>)
 8000c0a:	f023 0304 	bic.w	r3, r3, #4
 8000c0e:	6013      	str	r3, [r2, #0]
	#endif
}
 8000c10:	bf00      	nop
 8000c12:	46bd      	mov	sp, r7
 8000c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c18:	4770      	bx	lr
 8000c1a:	bf00      	nop
 8000c1c:	e000e010 	.word	0xe000e010

08000c20 <MSTK_voidStart>:

/*******************************************************************************************************/
/*                                      02- MSTK_voidStart                                              */
void MSTK_voidStart( u32 Copy_PreloadValue ){
 8000c20:	b480      	push	{r7}
 8000c22:	b083      	sub	sp, #12
 8000c24:	af00      	add	r7, sp, #0
 8000c26:	6078      	str	r0, [r7, #4]

	//Load Reload Value
	MSTK->LOAD = Copy_PreloadValue;
 8000c28:	4a12      	ldr	r2, [pc, #72]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c2a:	687b      	ldr	r3, [r7, #4]
 8000c2c:	6053      	str	r3, [r2, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000c2e:	4b11      	ldr	r3, [pc, #68]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c30:	2200      	movs	r2, #0
 8000c32:	609a      	str	r2, [r3, #8]
	/* Enable Systick    */
	SET_BIT( MSTK->CTRL , 0 );
 8000c34:	4b0f      	ldr	r3, [pc, #60]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c36:	681b      	ldr	r3, [r3, #0]
 8000c38:	4a0e      	ldr	r2, [pc, #56]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c3a:	f043 0301 	orr.w	r3, r3, #1
 8000c3e:	6013      	str	r3, [r2, #0]
	/*  POLL On the Counter Flag */
	while(GET_BIT( MSTK->CTRL , COUNTFLAG ) == 0);
 8000c40:	bf00      	nop
 8000c42:	4b0c      	ldr	r3, [pc, #48]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c44:	681b      	ldr	r3, [r3, #0]
 8000c46:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000c4a:	2b00      	cmp	r3, #0
 8000c4c:	d0f9      	beq.n	8000c42 <MSTK_voidStart+0x22>

	/*		Stop Timer 						*/
	CLR_BIT(MSTK->CTRL , 0);
 8000c4e:	4b09      	ldr	r3, [pc, #36]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c50:	681b      	ldr	r3, [r3, #0]
 8000c52:	4a08      	ldr	r2, [pc, #32]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c54:	f023 0301 	bic.w	r3, r3, #1
 8000c58:	6013      	str	r3, [r2, #0]
	/* Clear Load Reload      */
	MSTK->LOAD = 0;
 8000c5a:	4b06      	ldr	r3, [pc, #24]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c5c:	2200      	movs	r2, #0
 8000c5e:	605a      	str	r2, [r3, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000c60:	4b04      	ldr	r3, [pc, #16]	; (8000c74 <MSTK_voidStart+0x54>)
 8000c62:	2200      	movs	r2, #0
 8000c64:	609a      	str	r2, [r3, #8]

}
 8000c66:	bf00      	nop
 8000c68:	370c      	adds	r7, #12
 8000c6a:	46bd      	mov	sp, r7
 8000c6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c70:	4770      	bx	lr
 8000c72:	bf00      	nop
 8000c74:	e000e010 	.word	0xe000e010

08000c78 <MSTK_voidStopInterval>:

/*******************************************************************************************************/
/*                                      03- MSTK_voidStopInterval                                              */
void MSTK_voidStopInterval(void) 
{
 8000c78:	b480      	push	{r7}
 8000c7a:	af00      	add	r7, sp, #0
    /*	Stop Timer 	*/
	CLR_BIT(MSTK->CTRL , 0);
 8000c7c:	4b08      	ldr	r3, [pc, #32]	; (8000ca0 <MSTK_voidStopInterval+0x28>)
 8000c7e:	681b      	ldr	r3, [r3, #0]
 8000c80:	4a07      	ldr	r2, [pc, #28]	; (8000ca0 <MSTK_voidStopInterval+0x28>)
 8000c82:	f023 0301 	bic.w	r3, r3, #1
 8000c86:	6013      	str	r3, [r2, #0]
	/* Clear Load Reload      */
	MSTK->LOAD = 0;
 8000c88:	4b05      	ldr	r3, [pc, #20]	; (8000ca0 <MSTK_voidStopInterval+0x28>)
 8000c8a:	2200      	movs	r2, #0
 8000c8c:	605a      	str	r2, [r3, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000c8e:	4b04      	ldr	r3, [pc, #16]	; (8000ca0 <MSTK_voidStopInterval+0x28>)
 8000c90:	2200      	movs	r2, #0
 8000c92:	609a      	str	r2, [r3, #8]
}
 8000c94:	bf00      	nop
 8000c96:	46bd      	mov	sp, r7
 8000c98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c9c:	4770      	bx	lr
 8000c9e:	bf00      	nop
 8000ca0:	e000e010 	.word	0xe000e010

08000ca4 <MSTK_voidReSetInterval>:
/*******************************************************************************************************/
/*                                      03- MSTK_voidReSetInterval                                             */
void MSTK_voidReSetInterval( u32 Copy_PreloadValue ){
 8000ca4:	b480      	push	{r7}
 8000ca6:	b083      	sub	sp, #12
 8000ca8:	af00      	add	r7, sp, #0
 8000caa:	6078      	str	r0, [r7, #4]

	/* Clear Load Reload      */
	MSTK->LOAD = 0;
 8000cac:	4b15      	ldr	r3, [pc, #84]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cae:	2200      	movs	r2, #0
 8000cb0:	605a      	str	r2, [r3, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000cb2:	4b14      	ldr	r3, [pc, #80]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cb4:	2200      	movs	r2, #0
 8000cb6:	609a      	str	r2, [r3, #8]

	//Load Reload Value
	MSTK->LOAD = Copy_PreloadValue;
 8000cb8:	4a12      	ldr	r2, [pc, #72]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cba:	687b      	ldr	r3, [r7, #4]
 8000cbc:	6053      	str	r3, [r2, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000cbe:	4b11      	ldr	r3, [pc, #68]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cc0:	2200      	movs	r2, #0
 8000cc2:	609a      	str	r2, [r3, #8]
	/* Enable Systick    */
	SET_BIT( MSTK->CTRL , 0 );
 8000cc4:	4b0f      	ldr	r3, [pc, #60]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cc6:	681b      	ldr	r3, [r3, #0]
 8000cc8:	4a0e      	ldr	r2, [pc, #56]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cca:	f043 0301 	orr.w	r3, r3, #1
 8000cce:	6013      	str	r3, [r2, #0]
	/*  POLL On the Counter Flag */
	while(GET_BIT( MSTK->CTRL , COUNTFLAG ) == 0);
 8000cd0:	bf00      	nop
 8000cd2:	4b0c      	ldr	r3, [pc, #48]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cd4:	681b      	ldr	r3, [r3, #0]
 8000cd6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000cda:	2b00      	cmp	r3, #0
 8000cdc:	d0f9      	beq.n	8000cd2 <MSTK_voidReSetInterval+0x2e>

	/*		Stop Timer 						*/
	CLR_BIT(MSTK->CTRL , 0);
 8000cde:	4b09      	ldr	r3, [pc, #36]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000ce0:	681b      	ldr	r3, [r3, #0]
 8000ce2:	4a08      	ldr	r2, [pc, #32]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000ce4:	f023 0301 	bic.w	r3, r3, #1
 8000ce8:	6013      	str	r3, [r2, #0]
	/* Clear Load Reload      */
	MSTK->LOAD = 0;
 8000cea:	4b06      	ldr	r3, [pc, #24]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cec:	2200      	movs	r2, #0
 8000cee:	605a      	str	r2, [r3, #4]
	/* Clear Val Register     */
	MSTK->VAL  = 0 ;
 8000cf0:	4b04      	ldr	r3, [pc, #16]	; (8000d04 <MSTK_voidReSetInterval+0x60>)
 8000cf2:	2200      	movs	r2, #0
 8000cf4:	609a      	str	r2, [r3, #8]

}
 8000cf6:	bf00      	nop
 8000cf8:	370c      	adds	r7, #12
 8000cfa:	46bd      	mov	sp, r7
 8000cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d00:	4770      	bx	lr
 8000d02:	bf00      	nop
 8000d04:	e000e010 	.word	0xe000e010

08000d08 <MSTK_voidSetIntervalSingle>:

/*******************************************************************************************************/
/*                                      04- MSTK_voidSetIntervalSingle                                              */
void	MSTK_voidSetIntervalSingle(u32 Ticks,void (*Copy_ptr)(void))
{
 8000d08:	b480      	push	{r7}
 8000d0a:	b083      	sub	sp, #12
 8000d0c:	af00      	add	r7, sp, #0
 8000d0e:	6078      	str	r0, [r7, #4]
 8000d10:	6039      	str	r1, [r7, #0]
	/*		tick time = 0.5 mic sec	when PROCCESOR_CLK_AHB_DIV8	*/ //error
	/*		Load Ticks to Load Register		*/
	MSTK->LOAD	= (u32)Ticks ;
 8000d12:	4a0d      	ldr	r2, [pc, #52]	; (8000d48 <MSTK_voidSetIntervalSingle+0x40>)
 8000d14:	687b      	ldr	r3, [r7, #4]
 8000d16:	6053      	str	r3, [r2, #4]
	/*		Start Timer 					*/
	SET_BIT(MSTK->CTRL , 0);
 8000d18:	4b0b      	ldr	r3, [pc, #44]	; (8000d48 <MSTK_voidSetIntervalSingle+0x40>)
 8000d1a:	681b      	ldr	r3, [r3, #0]
 8000d1c:	4a0a      	ldr	r2, [pc, #40]	; (8000d48 <MSTK_voidSetIntervalSingle+0x40>)
 8000d1e:	f043 0301 	orr.w	r3, r3, #1
 8000d22:	6013      	str	r3, [r2, #0]
	/*		Save CallBack					*/
	MSTK_CallBack = Copy_ptr;
 8000d24:	4a09      	ldr	r2, [pc, #36]	; (8000d4c <MSTK_voidSetIntervalSingle+0x44>)
 8000d26:	683b      	ldr	r3, [r7, #0]
 8000d28:	6013      	str	r3, [r2, #0]
	/*		Software Flage to indicate which callback will execute	*/
	MSTK_u8ModeOfInterval = MSTK_SINGLE_INTERVAL;
 8000d2a:	4b09      	ldr	r3, [pc, #36]	; (8000d50 <MSTK_voidSetIntervalSingle+0x48>)
 8000d2c:	2201      	movs	r2, #1
 8000d2e:	701a      	strb	r2, [r3, #0]
	/*		SysTick Interrupt Enable PIE	*/
	SET_BIT(MSTK->CTRL , 1);
 8000d30:	4b05      	ldr	r3, [pc, #20]	; (8000d48 <MSTK_voidSetIntervalSingle+0x40>)
 8000d32:	681b      	ldr	r3, [r3, #0]
 8000d34:	4a04      	ldr	r2, [pc, #16]	; (8000d48 <MSTK_voidSetIntervalSingle+0x40>)
 8000d36:	f043 0302 	orr.w	r3, r3, #2
 8000d3a:	6013      	str	r3, [r2, #0]

}
 8000d3c:	bf00      	nop
 8000d3e:	370c      	adds	r7, #12
 8000d40:	46bd      	mov	sp, r7
 8000d42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d46:	4770      	bx	lr
 8000d48:	e000e010 	.word	0xe000e010
 8000d4c:	20000108 	.word	0x20000108
 8000d50:	2000010c 	.word	0x2000010c

08000d54 <_delay_ms>:
	return local_u32ElapsedTime;
}

/*******************************************************************************************************/
/*                                      09- _delay_ms                                              */
void _delay_ms( u32 Copy_u32Time ){
 8000d54:	b580      	push	{r7, lr}
 8000d56:	b082      	sub	sp, #8
 8000d58:	af00      	add	r7, sp, #0
 8000d5a:	6078      	str	r0, [r7, #4]

	MSTK_voidInit();
 8000d5c:	f7ff ff50 	bl	8000c00 <MSTK_voidInit>
	/*	1- Disable the Interrupt 	*/
	CLR_BIT(MSTK->CTRL , 1);
 8000d60:	4b09      	ldr	r3, [pc, #36]	; (8000d88 <_delay_ms+0x34>)
 8000d62:	681b      	ldr	r3, [r3, #0]
 8000d64:	4a08      	ldr	r2, [pc, #32]	; (8000d88 <_delay_ms+0x34>)
 8000d66:	f023 0302 	bic.w	r3, r3, #2
 8000d6a:	6013      	str	r3, [r2, #0]
	
	MSTK_voidStart( Copy_u32Time * 2000 );
 8000d6c:	687b      	ldr	r3, [r7, #4]
 8000d6e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8000d72:	fb02 f303 	mul.w	r3, r2, r3
 8000d76:	4618      	mov	r0, r3
 8000d78:	f7ff ff52 	bl	8000c20 <MSTK_voidStart>
	/*    Stop Timer      */
	MSTK_voidStopInterval();
 8000d7c:	f7ff ff7c 	bl	8000c78 <MSTK_voidStopInterval>

}
 8000d80:	bf00      	nop
 8000d82:	3708      	adds	r7, #8
 8000d84:	46bd      	mov	sp, r7
 8000d86:	bd80      	pop	{r7, pc}
 8000d88:	e000e010 	.word	0xe000e010

08000d8c <SysTick_Handler>:

/*******************************************************************************************************/
/*                                      //Core Peripheral                                              */

void	SysTick_Handler(void)
{
 8000d8c:	b580      	push	{r7, lr}
 8000d8e:	b082      	sub	sp, #8
 8000d90:	af00      	add	r7, sp, #0
	u8 Local_u8Temp = 0;
 8000d92:	2300      	movs	r3, #0
 8000d94:	71fb      	strb	r3, [r7, #7]
	if(MSTK_u8ModeOfInterval == MSTK_SINGLE_INTERVAL)
 8000d96:	4b14      	ldr	r3, [pc, #80]	; (8000de8 <SysTick_Handler+0x5c>)
 8000d98:	781b      	ldrb	r3, [r3, #0]
 8000d9a:	2b01      	cmp	r3, #1
 8000d9c:	d111      	bne.n	8000dc2 <SysTick_Handler+0x36>
	{
		/*	1- Disable the Interrupt 	*/
			CLR_BIT(MSTK->CTRL , 1);
 8000d9e:	4b13      	ldr	r3, [pc, #76]	; (8000dec <SysTick_Handler+0x60>)
 8000da0:	681b      	ldr	r3, [r3, #0]
 8000da2:	4a12      	ldr	r2, [pc, #72]	; (8000dec <SysTick_Handler+0x60>)
 8000da4:	f023 0302 	bic.w	r3, r3, #2
 8000da8:	6013      	str	r3, [r2, #0]
		/*	2- Stop the timer			*/
			CLR_BIT(MSTK->CTRL , 0);
 8000daa:	4b10      	ldr	r3, [pc, #64]	; (8000dec <SysTick_Handler+0x60>)
 8000dac:	681b      	ldr	r3, [r3, #0]
 8000dae:	4a0f      	ldr	r2, [pc, #60]	; (8000dec <SysTick_Handler+0x60>)
 8000db0:	f023 0301 	bic.w	r3, r3, #1
 8000db4:	6013      	str	r3, [r2, #0]
			MSTK->LOAD	= 0;
 8000db6:	4b0d      	ldr	r3, [pc, #52]	; (8000dec <SysTick_Handler+0x60>)
 8000db8:	2200      	movs	r2, #0
 8000dba:	605a      	str	r2, [r3, #4]
			MSTK->VAL	= 0;
 8000dbc:	4b0b      	ldr	r3, [pc, #44]	; (8000dec <SysTick_Handler+0x60>)
 8000dbe:	2200      	movs	r2, #0
 8000dc0:	609a      	str	r2, [r3, #8]
	}
	 /*Execute Action to be done after the time passed*/
	if(MSTK_CallBack !=NULL)
 8000dc2:	4b0b      	ldr	r3, [pc, #44]	; (8000df0 <SysTick_Handler+0x64>)
 8000dc4:	681b      	ldr	r3, [r3, #0]
 8000dc6:	2b00      	cmp	r3, #0
 8000dc8:	d002      	beq.n	8000dd0 <SysTick_Handler+0x44>
	{	
	MSTK_CallBack();
 8000dca:	4b09      	ldr	r3, [pc, #36]	; (8000df0 <SysTick_Handler+0x64>)
 8000dcc:	681b      	ldr	r3, [r3, #0]
 8000dce:	4798      	blx	r3
	}
	/*	Clear Interrupt Flag by reading the Flag */
	Local_u8Temp	=	GET_BIT(MSTK->CTRL , COUNTFLAG);
 8000dd0:	4b06      	ldr	r3, [pc, #24]	; (8000dec <SysTick_Handler+0x60>)
 8000dd2:	681b      	ldr	r3, [r3, #0]
 8000dd4:	0c1b      	lsrs	r3, r3, #16
 8000dd6:	b2db      	uxtb	r3, r3
 8000dd8:	f003 0301 	and.w	r3, r3, #1
 8000ddc:	71fb      	strb	r3, [r7, #7]
}
 8000dde:	bf00      	nop
 8000de0:	3708      	adds	r7, #8
 8000de2:	46bd      	mov	sp, r7
 8000de4:	bd80      	pop	{r7, pc}
 8000de6:	bf00      	nop
 8000de8:	2000010c 	.word	0x2000010c
 8000dec:	e000e010 	.word	0xe000e010
 8000df0:	20000108 	.word	0x20000108

08000df4 <MUSART_voidInit>:
/*******************************************************************************************************/


/*******************************************************************************************************/
void MUSART_voidInit(void)
{
 8000df4:	b480      	push	{r7}
 8000df6:	af00      	add	r7, sp, #0

	/***********	USART_1		***********/
#if (USART1_USED == U_ENABLE)
	/**< Configure USART baud rate  */
	USART1_REG->BRR = USART1_BUAD_RATE;
 8000df8:	4b1c      	ldr	r3, [pc, #112]	; (8000e6c <MUSART_voidInit+0x78>)
 8000dfa:	f240 6283 	movw	r2, #1667	; 0x683
 8000dfe:	609a      	str	r2, [r3, #8]
	/**< Configure USART stop bits */
	USART1_REG->CR2 |= (USART1_STOP_BITS << 12);
 8000e00:	4b1a      	ldr	r3, [pc, #104]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e02:	4a1a      	ldr	r2, [pc, #104]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e04:	691b      	ldr	r3, [r3, #16]
 8000e06:	6113      	str	r3, [r2, #16]
	/**< Configure USART send break character */
	USART1_REG->CR1.SBK = USART1_SEND_BREAK;
 8000e08:	4a18      	ldr	r2, [pc, #96]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e0a:	68d3      	ldr	r3, [r2, #12]
 8000e0c:	f36f 0300 	bfc	r3, #0, #1
 8000e10:	60d3      	str	r3, [r2, #12]
	/**< Configure USART RX enable/Disable */
	USART1_REG->CR1.RE = USART1_RECEIVER;
 8000e12:	4a16      	ldr	r2, [pc, #88]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e14:	68d3      	ldr	r3, [r2, #12]
 8000e16:	f043 0304 	orr.w	r3, r3, #4
 8000e1a:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 TX enable/Disable */
	USART1_REG->CR1.TE = USART1_TRANSMITTER;
 8000e1c:	4a13      	ldr	r2, [pc, #76]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e1e:	68d3      	ldr	r3, [r2, #12]
 8000e20:	f043 0308 	orr.w	r3, r3, #8
 8000e24:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 RX Interrupt enable/Disable */
	USART1_REG->CR1.RXNEIE = USART1_RX_INT;
 8000e26:	4a11      	ldr	r2, [pc, #68]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e28:	68d3      	ldr	r3, [r2, #12]
 8000e2a:	f36f 1345 	bfc	r3, #5, #1
 8000e2e:	60d3      	str	r3, [r2, #12]
	/*< Configure USART1 Transmission complete interrupt enable/disable/*/
	USART1_REG->CR1.TCIE = USART1_T_COMP_INT;
 8000e30:	4a0e      	ldr	r2, [pc, #56]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e32:	68d3      	ldr	r3, [r2, #12]
 8000e34:	f36f 1386 	bfc	r3, #6, #1
 8000e38:	60d3      	str	r3, [r2, #12]
	/**< Enable/Disable USART1 parity mode */
	USART1_REG->CR1.PCE = USART1_PARITY_ENABLE;
 8000e3a:	4a0c      	ldr	r2, [pc, #48]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e3c:	68d3      	ldr	r3, [r2, #12]
 8000e3e:	f36f 238a 	bfc	r3, #10, #1
 8000e42:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 parity mode */
	USART1_REG->CR1.PS = USART1_PARITY_MODE;
 8000e44:	4a09      	ldr	r2, [pc, #36]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e46:	68d3      	ldr	r3, [r2, #12]
 8000e48:	f36f 2349 	bfc	r3, #9, #1
 8000e4c:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 word length (data bits) */
	USART1_REG->CR1.M = USART1_WORD_LEN;
 8000e4e:	4a07      	ldr	r2, [pc, #28]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e50:	68d3      	ldr	r3, [r2, #12]
 8000e52:	f36f 330c 	bfc	r3, #12, #1
 8000e56:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 Over-sampling mode */
	USART1_REG->CR1.OVER8	= USART1_OVER_SAMPLING;
 8000e58:	4a04      	ldr	r2, [pc, #16]	; (8000e6c <MUSART_voidInit+0x78>)
 8000e5a:	68d3      	ldr	r3, [r2, #12]
 8000e5c:	f36f 33cf 	bfc	r3, #15, #1
 8000e60:	60d3      	str	r3, [r2, #12]
	/**< Configure USART1 word length (data bits) */
	USART6_REG->CR1.M = USART6_WORD_LEN;
	/**< Configure USART1 Over-sampling mode */
	USART6_REG->CR1.OVER8	= USART6_OVER_SAMPLING;
#endif
}
 8000e62:	bf00      	nop
 8000e64:	46bd      	mov	sp, r7
 8000e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e6a:	4770      	bx	lr
 8000e6c:	40011000 	.word	0x40011000

08000e70 <MUSART_voidEnable>:

/*******************************************************************************************************/

void MUSART_voidEnable(u8 copy_u8Index){
 8000e70:	b480      	push	{r7}
 8000e72:	b083      	sub	sp, #12
 8000e74:	af00      	add	r7, sp, #0
 8000e76:	4603      	mov	r3, r0
 8000e78:	71fb      	strb	r3, [r7, #7]
	switch(copy_u8Index){
 8000e7a:	79fb      	ldrb	r3, [r7, #7]
 8000e7c:	2b06      	cmp	r3, #6
 8000e7e:	d012      	beq.n	8000ea6 <MUSART_voidEnable+0x36>
 8000e80:	2b06      	cmp	r3, #6
 8000e82:	dc16      	bgt.n	8000eb2 <MUSART_voidEnable+0x42>
 8000e84:	2b01      	cmp	r3, #1
 8000e86:	d002      	beq.n	8000e8e <MUSART_voidEnable+0x1e>
 8000e88:	2b02      	cmp	r3, #2
 8000e8a:	d006      	beq.n	8000e9a <MUSART_voidEnable+0x2a>
	case 1: USART1_REG -> CR1.UE = 1; break;
	case 2: USART2_REG -> CR1.UE = 1; break;
	case 6: USART6_REG -> CR1.UE = 1; break;
	}
}
 8000e8c:	e011      	b.n	8000eb2 <MUSART_voidEnable+0x42>
	case 1: USART1_REG -> CR1.UE = 1; break;
 8000e8e:	4a0c      	ldr	r2, [pc, #48]	; (8000ec0 <MUSART_voidEnable+0x50>)
 8000e90:	68d3      	ldr	r3, [r2, #12]
 8000e92:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000e96:	60d3      	str	r3, [r2, #12]
 8000e98:	e00b      	b.n	8000eb2 <MUSART_voidEnable+0x42>
	case 2: USART2_REG -> CR1.UE = 1; break;
 8000e9a:	4a0a      	ldr	r2, [pc, #40]	; (8000ec4 <MUSART_voidEnable+0x54>)
 8000e9c:	68d3      	ldr	r3, [r2, #12]
 8000e9e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000ea2:	60d3      	str	r3, [r2, #12]
 8000ea4:	e005      	b.n	8000eb2 <MUSART_voidEnable+0x42>
	case 6: USART6_REG -> CR1.UE = 1; break;
 8000ea6:	4a08      	ldr	r2, [pc, #32]	; (8000ec8 <MUSART_voidEnable+0x58>)
 8000ea8:	68d3      	ldr	r3, [r2, #12]
 8000eaa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000eae:	60d3      	str	r3, [r2, #12]
 8000eb0:	bf00      	nop
}
 8000eb2:	bf00      	nop
 8000eb4:	370c      	adds	r7, #12
 8000eb6:	46bd      	mov	sp, r7
 8000eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ebc:	4770      	bx	lr
 8000ebe:	bf00      	nop
 8000ec0:	40011000 	.word	0x40011000
 8000ec4:	40004400 	.word	0x40004400
 8000ec8:	40011400 	.word	0x40011400

08000ecc <MUSART_voidDisable>:

/*******************************************************************************************************/

void MUSART_voidDisable(u8 copy_u8Index){
 8000ecc:	b480      	push	{r7}
 8000ece:	b083      	sub	sp, #12
 8000ed0:	af00      	add	r7, sp, #0
 8000ed2:	4603      	mov	r3, r0
 8000ed4:	71fb      	strb	r3, [r7, #7]
	switch (copy_u8Index)
 8000ed6:	79fb      	ldrb	r3, [r7, #7]
 8000ed8:	2b06      	cmp	r3, #6
 8000eda:	d012      	beq.n	8000f02 <MUSART_voidDisable+0x36>
 8000edc:	2b06      	cmp	r3, #6
 8000ede:	dc16      	bgt.n	8000f0e <MUSART_voidDisable+0x42>
 8000ee0:	2b01      	cmp	r3, #1
 8000ee2:	d002      	beq.n	8000eea <MUSART_voidDisable+0x1e>
 8000ee4:	2b02      	cmp	r3, #2
 8000ee6:	d006      	beq.n	8000ef6 <MUSART_voidDisable+0x2a>
	{
	case 1: USART1_REG -> CR1.UE = 0; break;
	case 2: USART2_REG -> CR1.UE = 0; break;
	case 6: USART6_REG -> CR1.UE = 0; break;
	}
}
 8000ee8:	e011      	b.n	8000f0e <MUSART_voidDisable+0x42>
	case 1: USART1_REG -> CR1.UE = 0; break;
 8000eea:	4a0c      	ldr	r2, [pc, #48]	; (8000f1c <MUSART_voidDisable+0x50>)
 8000eec:	68d3      	ldr	r3, [r2, #12]
 8000eee:	f36f 334d 	bfc	r3, #13, #1
 8000ef2:	60d3      	str	r3, [r2, #12]
 8000ef4:	e00b      	b.n	8000f0e <MUSART_voidDisable+0x42>
	case 2: USART2_REG -> CR1.UE = 0; break;
 8000ef6:	4a0a      	ldr	r2, [pc, #40]	; (8000f20 <MUSART_voidDisable+0x54>)
 8000ef8:	68d3      	ldr	r3, [r2, #12]
 8000efa:	f36f 334d 	bfc	r3, #13, #1
 8000efe:	60d3      	str	r3, [r2, #12]
 8000f00:	e005      	b.n	8000f0e <MUSART_voidDisable+0x42>
	case 6: USART6_REG -> CR1.UE = 0; break;
 8000f02:	4a08      	ldr	r2, [pc, #32]	; (8000f24 <MUSART_voidDisable+0x58>)
 8000f04:	68d3      	ldr	r3, [r2, #12]
 8000f06:	f36f 334d 	bfc	r3, #13, #1
 8000f0a:	60d3      	str	r3, [r2, #12]
 8000f0c:	bf00      	nop
}
 8000f0e:	bf00      	nop
 8000f10:	370c      	adds	r7, #12
 8000f12:	46bd      	mov	sp, r7
 8000f14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f18:	4770      	bx	lr
 8000f1a:	bf00      	nop
 8000f1c:	40011000 	.word	0x40011000
 8000f20:	40004400 	.word	0x40004400
 8000f24:	40011400 	.word	0x40011400

08000f28 <MUSART_u8Send_Byte>:

/*******************************************************************************************************/
void MUSART_u8Send_Byte(u8 copy_u8Index ,u8 copy_u8Data){
 8000f28:	b580      	push	{r7, lr}
 8000f2a:	b084      	sub	sp, #16
 8000f2c:	af00      	add	r7, sp, #0
 8000f2e:	4603      	mov	r3, r0
 8000f30:	460a      	mov	r2, r1
 8000f32:	71fb      	strb	r3, [r7, #7]
 8000f34:	4613      	mov	r3, r2
 8000f36:	71bb      	strb	r3, [r7, #6]
	USART_REG _USART_ = MUSART_SetUSART(copy_u8Index);
 8000f38:	79fb      	ldrb	r3, [r7, #7]
 8000f3a:	4618      	mov	r0, r3
 8000f3c:	f000 f838 	bl	8000fb0 <MUSART_SetUSART>
 8000f40:	60f8      	str	r0, [r7, #12]
	while(0==GET_BIT(_USART_->SR, 7));// wait until transmission complete into the shift register
 8000f42:	bf00      	nop
 8000f44:	68fb      	ldr	r3, [r7, #12]
 8000f46:	681b      	ldr	r3, [r3, #0]
 8000f48:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000f4c:	2b00      	cmp	r3, #0
 8000f4e:	d0f9      	beq.n	8000f44 <MUSART_u8Send_Byte+0x1c>
	_USART_->DR = copy_u8Data;
 8000f50:	79ba      	ldrb	r2, [r7, #6]
 8000f52:	68fb      	ldr	r3, [r7, #12]
 8000f54:	605a      	str	r2, [r3, #4]
	while(0==GET_BIT(_USART_->SR, 6));// wait until transmission of a frame containing data is complete
 8000f56:	bf00      	nop
 8000f58:	68fb      	ldr	r3, [r7, #12]
 8000f5a:	681b      	ldr	r3, [r3, #0]
 8000f5c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000f60:	2b00      	cmp	r3, #0
 8000f62:	d0f9      	beq.n	8000f58 <MUSART_u8Send_Byte+0x30>
}
 8000f64:	bf00      	nop
 8000f66:	bf00      	nop
 8000f68:	3710      	adds	r7, #16
 8000f6a:	46bd      	mov	sp, r7
 8000f6c:	bd80      	pop	{r7, pc}

08000f6e <MUSART_u8Receive_Byte>:
		MUSART_u8Send_Byte(copy_u8Index,copy_u8Data[Local_u8Index]);
		Local_u8Index++;
	}
}
/*******************************************************************************************************/
u8 MUSART_u8Receive_Byte(u8 copy_u8Index,u8 *copy_u8Data){
 8000f6e:	b580      	push	{r7, lr}
 8000f70:	b084      	sub	sp, #16
 8000f72:	af00      	add	r7, sp, #0
 8000f74:	4603      	mov	r3, r0
 8000f76:	6039      	str	r1, [r7, #0]
 8000f78:	71fb      	strb	r3, [r7, #7]
	USART_REG _USART_ = MUSART_SetUSART(copy_u8Index);
 8000f7a:	79fb      	ldrb	r3, [r7, #7]
 8000f7c:	4618      	mov	r0, r3
 8000f7e:	f000 f817 	bl	8000fb0 <MUSART_SetUSART>
 8000f82:	60b8      	str	r0, [r7, #8]
	u8 Statue = Receive;
 8000f84:	2301      	movs	r3, #1
 8000f86:	73fb      	strb	r3, [r7, #15]
	if( GET_BIT( _USART_->SR ,5) == 1 )
 8000f88:	68bb      	ldr	r3, [r7, #8]
 8000f8a:	681b      	ldr	r3, [r3, #0]
 8000f8c:	095b      	lsrs	r3, r3, #5
 8000f8e:	f003 0301 	and.w	r3, r3, #1
 8000f92:	2b01      	cmp	r3, #1
 8000f94:	d105      	bne.n	8000fa2 <MUSART_u8Receive_Byte+0x34>
	{
		*copy_u8Data= _USART_->DR;
 8000f96:	68bb      	ldr	r3, [r7, #8]
 8000f98:	685b      	ldr	r3, [r3, #4]
 8000f9a:	b2da      	uxtb	r2, r3
 8000f9c:	683b      	ldr	r3, [r7, #0]
 8000f9e:	701a      	strb	r2, [r3, #0]
 8000fa0:	e001      	b.n	8000fa6 <MUSART_u8Receive_Byte+0x38>
	}
	else
	{
		Statue = NoReceive ;
 8000fa2:	2300      	movs	r3, #0
 8000fa4:	73fb      	strb	r3, [r7, #15]
	}
		return Statue ;
 8000fa6:	7bfb      	ldrb	r3, [r7, #15]
}
 8000fa8:	4618      	mov	r0, r3
 8000faa:	3710      	adds	r7, #16
 8000fac:	46bd      	mov	sp, r7
 8000fae:	bd80      	pop	{r7, pc}

08000fb0 <MUSART_SetUSART>:
	*copy_u8Data= _USART_->DR;
	return *copy_u8Data ;

}
/*******************************************************************************************************/
USART_REG MUSART_SetUSART(u8 copy_u8Index){
 8000fb0:	b480      	push	{r7}
 8000fb2:	b085      	sub	sp, #20
 8000fb4:	af00      	add	r7, sp, #0
 8000fb6:	4603      	mov	r3, r0
 8000fb8:	71fb      	strb	r3, [r7, #7]
	USART_REG L_handle= (USART_REG) USART1_BASE_ADRESS;
 8000fba:	4b0e      	ldr	r3, [pc, #56]	; (8000ff4 <MUSART_SetUSART+0x44>)
 8000fbc:	60fb      	str	r3, [r7, #12]
	switch (copy_u8Index)
 8000fbe:	79fb      	ldrb	r3, [r7, #7]
 8000fc0:	2b06      	cmp	r3, #6
 8000fc2:	d00c      	beq.n	8000fde <MUSART_SetUSART+0x2e>
 8000fc4:	2b06      	cmp	r3, #6
 8000fc6:	dc0d      	bgt.n	8000fe4 <MUSART_SetUSART+0x34>
 8000fc8:	2b01      	cmp	r3, #1
 8000fca:	d002      	beq.n	8000fd2 <MUSART_SetUSART+0x22>
 8000fcc:	2b02      	cmp	r3, #2
 8000fce:	d003      	beq.n	8000fd8 <MUSART_SetUSART+0x28>
 8000fd0:	e008      	b.n	8000fe4 <MUSART_SetUSART+0x34>
	{
	case 1: L_handle =  (USART_REG) USART1_BASE_ADRESS; break;
 8000fd2:	4b08      	ldr	r3, [pc, #32]	; (8000ff4 <MUSART_SetUSART+0x44>)
 8000fd4:	60fb      	str	r3, [r7, #12]
 8000fd6:	e005      	b.n	8000fe4 <MUSART_SetUSART+0x34>
	case 2: L_handle =  (USART_REG) USART2_BASE_ADRESS; break;
 8000fd8:	4b07      	ldr	r3, [pc, #28]	; (8000ff8 <MUSART_SetUSART+0x48>)
 8000fda:	60fb      	str	r3, [r7, #12]
 8000fdc:	e002      	b.n	8000fe4 <MUSART_SetUSART+0x34>
	case 6: L_handle =  (USART_REG) USART6_BASE_ADRESS; break;
 8000fde:	4b07      	ldr	r3, [pc, #28]	; (8000ffc <MUSART_SetUSART+0x4c>)
 8000fe0:	60fb      	str	r3, [r7, #12]
 8000fe2:	bf00      	nop
	}
	return L_handle;
 8000fe4:	68fb      	ldr	r3, [r7, #12]
}
 8000fe6:	4618      	mov	r0, r3
 8000fe8:	3714      	adds	r7, #20
 8000fea:	46bd      	mov	sp, r7
 8000fec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ff0:	4770      	bx	lr
 8000ff2:	bf00      	nop
 8000ff4:	40011000 	.word	0x40011000
 8000ff8:	40004400 	.word	0x40004400
 8000ffc:	40011400 	.word	0x40011400

08001000 <USART1_IRQHandler>:
}

/*******************************************************************************************************/
/** ISR of USART1 **/
void USART1_IRQHandler(void)
{
 8001000:	b580      	push	{r7, lr}
 8001002:	af00      	add	r7, sp, #0
	USART1_REG->SR = 0 ;	//reset flags
 8001004:	4b03      	ldr	r3, [pc, #12]	; (8001014 <USART1_IRQHandler+0x14>)
 8001006:	2200      	movs	r2, #0
 8001008:	601a      	str	r2, [r3, #0]
	USART_USART1Function();
 800100a:	4b03      	ldr	r3, [pc, #12]	; (8001018 <USART1_IRQHandler+0x18>)
 800100c:	681b      	ldr	r3, [r3, #0]
 800100e:	4798      	blx	r3
}
 8001010:	bf00      	nop
 8001012:	bd80      	pop	{r7, pc}
 8001014:	40011000 	.word	0x40011000
 8001018:	20000110 	.word	0x20000110

0800101c <USART2_IRQHandler>:

/** ISR of USART2 **/
void USART2_IRQHandler(void)
{
 800101c:	b580      	push	{r7, lr}
 800101e:	af00      	add	r7, sp, #0
	USART2_REG->SR = 0 ;
 8001020:	4b03      	ldr	r3, [pc, #12]	; (8001030 <USART2_IRQHandler+0x14>)
 8001022:	2200      	movs	r2, #0
 8001024:	601a      	str	r2, [r3, #0]
	USART_USART2Function();
 8001026:	4b03      	ldr	r3, [pc, #12]	; (8001034 <USART2_IRQHandler+0x18>)
 8001028:	681b      	ldr	r3, [r3, #0]
 800102a:	4798      	blx	r3
}
 800102c:	bf00      	nop
 800102e:	bd80      	pop	{r7, pc}
 8001030:	40004400 	.word	0x40004400
 8001034:	20000114 	.word	0x20000114

08001038 <USART6_IRQHandler>:

/** ISR of USART6 **/
void USART6_IRQHandler(void)
{
 8001038:	b580      	push	{r7, lr}
 800103a:	af00      	add	r7, sp, #0
	USART6_REG->SR = 0 ;
 800103c:	4b03      	ldr	r3, [pc, #12]	; (800104c <USART6_IRQHandler+0x14>)
 800103e:	2200      	movs	r2, #0
 8001040:	601a      	str	r2, [r3, #0]
	USART_USART6Function();
 8001042:	4b03      	ldr	r3, [pc, #12]	; (8001050 <USART6_IRQHandler+0x18>)
 8001044:	681b      	ldr	r3, [r3, #0]
 8001046:	4798      	blx	r3
}
 8001048:	bf00      	nop
 800104a:	bd80      	pop	{r7, pc}
 800104c:	40011400 	.word	0x40011400
 8001050:	20000118 	.word	0x20000118

08001054 <main>:
/* functions deceleration  END */
/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

int main(void)
{
 8001054:	b580      	push	{r7, lr}
 8001056:	b082      	sub	sp, #8
 8001058:	af00      	add	r7, sp, #0
	/*Initialize System Clock to be 16MHz from HSI*/
	MRCC_voidInitSystemClk();
 800105a:	f7ff fdb5 	bl	8000bc8 <MRCC_voidInitSystemClk>
	/*SysTick initialize*/
	MSTK_voidInit();
 800105e:	f7ff fdcf 	bl	8000c00 <MSTK_voidInit>
	_delay_ms(500);
 8001062:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001066:	f7ff fe75 	bl	8000d54 <_delay_ms>
	/*Initialize  USART GPIO clock*/
	MRCC_voidEnablePeripheralClock(AHB1,GPIOA_PORT);
 800106a:	2100      	movs	r1, #0
 800106c:	2000      	movs	r0, #0
 800106e:	f7ff fd03 	bl	8000a78 <MRCC_voidEnablePeripheralClock>
	/*Initialize the USART*/
	MRCC_voidEnablePeripheralClock(APB2,PERIPHERAL_EN_USART1);
 8001072:	2104      	movs	r1, #4
 8001074:	2003      	movs	r0, #3
 8001076:	f7ff fcff 	bl	8000a78 <MRCC_voidEnablePeripheralClock>
	MGPIO_voidSetPinMode (GPIOA_PORT, PIN_9,  MODE_ALTF);
 800107a:	2202      	movs	r2, #2
 800107c:	2109      	movs	r1, #9
 800107e:	2000      	movs	r0, #0
 8001080:	f7ff fb9e 	bl	80007c0 <MGPIO_voidSetPinMode>
	MGPIO_voidSetPinMode (GPIOA_PORT, PIN_10, MODE_ALTF);
 8001084:	2202      	movs	r2, #2
 8001086:	210a      	movs	r1, #10
 8001088:	2000      	movs	r0, #0
 800108a:	f7ff fb99 	bl	80007c0 <MGPIO_voidSetPinMode>
	MGPIO_voidSetPinAltFn(GPIOA_PORT, PIN_9,  ALTFN_7);
 800108e:	2207      	movs	r2, #7
 8001090:	2109      	movs	r1, #9
 8001092:	2000      	movs	r0, #0
 8001094:	f7ff fc0c 	bl	80008b0 <MGPIO_voidSetPinAltFn>
	MGPIO_voidSetPinAltFn(GPIOA_PORT, PIN_10, ALTFN_7);
 8001098:	2207      	movs	r2, #7
 800109a:	210a      	movs	r1, #10
 800109c:	2000      	movs	r0, #0
 800109e:	f7ff fc07 	bl	80008b0 <MGPIO_voidSetPinAltFn>
	/*USART initialize and enable*/
	MUSART_voidInit();
 80010a2:	f7ff fea7 	bl	8000df4 <MUSART_voidInit>
	MUSART_voidEnable(USART1);
 80010a6:	2001      	movs	r0, #1
 80010a8:	f7ff fee2 	bl	8000e70 <MUSART_voidEnable>
	//LED_Off (&Led_0);
	//LED_Init(&Led_3);

	/* begin ---------------------------------------------------------*/
	/*check on the currant App (in sector 4 and 5 )*/
	if ( UpDate_Flag == No_APP )
 80010ac:	4b6e      	ldr	r3, [pc, #440]	; (8001268 <main+0x214>)
 80010ae:	681b      	ldr	r3, [r3, #0]
 80010b0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80010b4:	d106      	bne.n	80010c4 <main+0x70>
	{
		CurrantAPP=0;// determined which App active
 80010b6:	4b6d      	ldr	r3, [pc, #436]	; (800126c <main+0x218>)
 80010b8:	2200      	movs	r2, #0
 80010ba:	701a      	strb	r2, [r3, #0]
		UpdateAPP =1;// determined which App will boot
 80010bc:	4b6c      	ldr	r3, [pc, #432]	; (8001270 <main+0x21c>)
 80010be:	2201      	movs	r2, #1
 80010c0:	701a      	strb	r2, [r3, #0]
 80010c2:	e016      	b.n	80010f2 <main+0x9e>
	}
	else if ( UpDate_Flag == APP_1_MID )
 80010c4:	4b68      	ldr	r3, [pc, #416]	; (8001268 <main+0x214>)
 80010c6:	681b      	ldr	r3, [r3, #0]
 80010c8:	4a6a      	ldr	r2, [pc, #424]	; (8001274 <main+0x220>)
 80010ca:	4293      	cmp	r3, r2
 80010cc:	d106      	bne.n	80010dc <main+0x88>
	{
		CurrantAPP=1;// determined which App active
 80010ce:	4b67      	ldr	r3, [pc, #412]	; (800126c <main+0x218>)
 80010d0:	2201      	movs	r2, #1
 80010d2:	701a      	strb	r2, [r3, #0]
		UpdateAPP =2;// determined which App will boot
 80010d4:	4b66      	ldr	r3, [pc, #408]	; (8001270 <main+0x21c>)
 80010d6:	2202      	movs	r2, #2
 80010d8:	701a      	strb	r2, [r3, #0]
 80010da:	e00a      	b.n	80010f2 <main+0x9e>
	}
	else if (UpDate_Flag == APP_2_MID )
 80010dc:	4b62      	ldr	r3, [pc, #392]	; (8001268 <main+0x214>)
 80010de:	681b      	ldr	r3, [r3, #0]
 80010e0:	4a65      	ldr	r2, [pc, #404]	; (8001278 <main+0x224>)
 80010e2:	4293      	cmp	r3, r2
 80010e4:	d105      	bne.n	80010f2 <main+0x9e>
	{
		CurrantAPP=2;// determined which App active
 80010e6:	4b61      	ldr	r3, [pc, #388]	; (800126c <main+0x218>)
 80010e8:	2202      	movs	r2, #2
 80010ea:	701a      	strb	r2, [r3, #0]
		UpdateAPP =1;// determined which App will boot
 80010ec:	4b60      	ldr	r3, [pc, #384]	; (8001270 <main+0x21c>)
 80010ee:	2201      	movs	r2, #1
 80010f0:	701a      	strb	r2, [r3, #0]


	/*Defending on the used communication protocol*/
#if (BL_communication == USART_COMM)
	/*send ACK to the gateway that BOOTLOADER is active now*/
	MUSART_u8Send_Byte(USART1,(u8*)'B');
 80010f2:	2142      	movs	r1, #66	; 0x42
 80010f4:	2001      	movs	r0, #1
 80010f6:	f7ff ff17 	bl	8000f28 <MUSART_u8Send_Byte>
	/*7.5 sec wait then call the callback function*/
	MSTK_voidSetIntervalSingle((u32)15000000,Func_CallBack);
 80010fa:	4960      	ldr	r1, [pc, #384]	; (800127c <main+0x228>)
 80010fc:	4860      	ldr	r0, [pc, #384]	; (8001280 <main+0x22c>)
 80010fe:	f7ff fe03 	bl	8000d08 <MSTK_voidSetIntervalSingle>
	/*USART receive statuses*/
	u8 LOC_u8RecStatus = NoReceive;
 8001102:	2300      	movs	r3, #0
 8001104:	71fb      	strb	r3, [r7, #7]

	while( TimeOutFlag == 0 )
 8001106:	e096      	b.n	8001236 <main+0x1e2>
	{
		LOC_u8RecStatus =MUSART_u8Receive_Byte(USART1,& u8RecBuffer[u8RecCounter]);	 //from the gateway
 8001108:	4b5e      	ldr	r3, [pc, #376]	; (8001284 <main+0x230>)
 800110a:	781b      	ldrb	r3, [r3, #0]
 800110c:	b2db      	uxtb	r3, r3
 800110e:	461a      	mov	r2, r3
 8001110:	4b5d      	ldr	r3, [pc, #372]	; (8001288 <main+0x234>)
 8001112:	4413      	add	r3, r2
 8001114:	4619      	mov	r1, r3
 8001116:	2001      	movs	r0, #1
 8001118:	f7ff ff29 	bl	8000f6e <MUSART_u8Receive_Byte>
 800111c:	4603      	mov	r3, r0
 800111e:	71fb      	strb	r3, [r7, #7]
		//---------------------------------------------------------------------------------------
		//---------------------------------	 Gateway receive	---------------------------------
		if( LOC_u8RecStatus == Receive )
 8001120:	79fb      	ldrb	r3, [r7, #7]
 8001122:	2b01      	cmp	r3, #1
 8001124:	f040 8087 	bne.w	8001236 <main+0x1e2>
		{
			/*Stop timer Application code in processing*/
			MSTK_voidStopInterval(); //----------------->>>>>>>>>>> MSTK_voidReSetInterval((u32)15000000);
 8001128:	f7ff fda6 	bl	8000c78 <MSTK_voidStopInterval>
			/*Collecting data in the buffer*/
			if( u8RecBuffer[u8RecCounter] == '\n' ){	//Indicate The end of the Record
 800112c:	4b55      	ldr	r3, [pc, #340]	; (8001284 <main+0x230>)
 800112e:	781b      	ldrb	r3, [r3, #0]
 8001130:	b2db      	uxtb	r3, r3
 8001132:	461a      	mov	r2, r3
 8001134:	4b54      	ldr	r3, [pc, #336]	; (8001288 <main+0x234>)
 8001136:	5c9b      	ldrb	r3, [r3, r2]
 8001138:	b2db      	uxtb	r3, r3
 800113a:	2b0a      	cmp	r3, #10
 800113c:	d164      	bne.n	8001208 <main+0x1b4>
				if( u8BLWriteReq == 1 ){
 800113e:	4b53      	ldr	r3, [pc, #332]	; (800128c <main+0x238>)
 8001140:	781b      	ldrb	r3, [r3, #0]
 8001142:	b2db      	uxtb	r3, r3
 8001144:	2b01      	cmp	r3, #1
 8001146:	d125      	bne.n	8001194 <main+0x140>
					if(u8RecBuffer[0] == '1' || u8RecBuffer[0] == '2'){
 8001148:	4b4f      	ldr	r3, [pc, #316]	; (8001288 <main+0x234>)
 800114a:	781b      	ldrb	r3, [r3, #0]
 800114c:	b2db      	uxtb	r3, r3
 800114e:	2b31      	cmp	r3, #49	; 0x31
 8001150:	d004      	beq.n	800115c <main+0x108>
 8001152:	4b4d      	ldr	r3, [pc, #308]	; (8001288 <main+0x234>)
 8001154:	781b      	ldrb	r3, [r3, #0]
 8001156:	b2db      	uxtb	r3, r3
 8001158:	2b32      	cmp	r3, #50	; 0x32
 800115a:	d107      	bne.n	800116c <main+0x118>
						MUSART_u8Send_Byte(USART1,(u8*)'B');
 800115c:	2142      	movs	r1, #66	; 0x42
 800115e:	2001      	movs	r0, #1
 8001160:	f7ff fee2 	bl	8000f28 <MUSART_u8Send_Byte>
						u8RecCounter = 0 ;
 8001164:	4b47      	ldr	r3, [pc, #284]	; (8001284 <main+0x230>)
 8001166:	2200      	movs	r2, #0
 8001168:	701a      	strb	r2, [r3, #0]
						continue;
 800116a:	e064      	b.n	8001236 <main+0x1e2>
					}
					/*Erase The Application Area*/
					if(UpdateAPP==1){
 800116c:	4b40      	ldr	r3, [pc, #256]	; (8001270 <main+0x21c>)
 800116e:	781b      	ldrb	r3, [r3, #0]
 8001170:	b2db      	uxtb	r3, r3
 8001172:	2b01      	cmp	r3, #1
 8001174:	d103      	bne.n	800117e <main+0x12a>
						MFMI_voidSectorErase(SECTOR_4);
 8001176:	2004      	movs	r0, #4
 8001178:	f7ff fa6c 	bl	8000654 <MFMI_voidSectorErase>
 800117c:	e007      	b.n	800118e <main+0x13a>
					}
					else if(UpdateAPP==2){
 800117e:	4b3c      	ldr	r3, [pc, #240]	; (8001270 <main+0x21c>)
 8001180:	781b      	ldrb	r3, [r3, #0]
 8001182:	b2db      	uxtb	r3, r3
 8001184:	2b02      	cmp	r3, #2
 8001186:	d102      	bne.n	800118e <main+0x13a>
						MFMI_voidSectorErase(SECTOR_5);
 8001188:	2005      	movs	r0, #5
 800118a:	f7ff fa63 	bl	8000654 <MFMI_voidSectorErase>
					}
					/*Set WriteReq Flag = 0 */
					u8BLWriteReq = 0 ;
 800118e:	4b3f      	ldr	r3, [pc, #252]	; (800128c <main+0x238>)
 8001190:	2200      	movs	r2, #0
 8001192:	701a      	strb	r2, [r3, #0]
				}
				/*Collecting check sum and send ACK to the gateway*/
				CS=HexParser_CheckSumOfData( u8RecBuffer );
 8001194:	483c      	ldr	r0, [pc, #240]	; (8001288 <main+0x234>)
 8001196:	f7ff f989 	bl	80004ac <HexParser_CheckSumOfData>
 800119a:	4603      	mov	r3, r0
 800119c:	461a      	mov	r2, r3
 800119e:	4b3c      	ldr	r3, [pc, #240]	; (8001290 <main+0x23c>)
 80011a0:	701a      	strb	r2, [r3, #0]
				if(CS==No_ERROR){
 80011a2:	4b3b      	ldr	r3, [pc, #236]	; (8001290 <main+0x23c>)
 80011a4:	781b      	ldrb	r3, [r3, #0]
 80011a6:	2b01      	cmp	r3, #1
 80011a8:	d10a      	bne.n	80011c0 <main+0x16c>
					/*Parse The record and write it to flash*/
					HexParser_vParseRecord ( u8RecBuffer );
 80011aa:	4837      	ldr	r0, [pc, #220]	; (8001288 <main+0x234>)
 80011ac:	f7ff f864 	bl	8000278 <HexParser_vParseRecord>
					/*send ok to the tool to send the next record*/
#if	(BL_IMT_DEBUGGING == ENABLE)
					MUSART_u8Send_Data(USART1,(u8 *)"ok");
#else
					MUSART_u8Send_Byte(USART1,(u8 *)'K');
 80011b0:	214b      	movs	r1, #75	; 0x4b
 80011b2:	2001      	movs	r0, #1
 80011b4:	f7ff feb8 	bl	8000f28 <MUSART_u8Send_Byte>
#endif
					Error_counter=0;
 80011b8:	4b36      	ldr	r3, [pc, #216]	; (8001294 <main+0x240>)
 80011ba:	2200      	movs	r2, #0
 80011bc:	701a      	strb	r2, [r3, #0]
 80011be:	e01f      	b.n	8001200 <main+0x1ac>
				}
				else{
					// send ACK to the gateway to send it again if the error happened 3 times it fail and back to the app
					Error_counter++;
 80011c0:	4b34      	ldr	r3, [pc, #208]	; (8001294 <main+0x240>)
 80011c2:	781b      	ldrb	r3, [r3, #0]
 80011c4:	3301      	adds	r3, #1
 80011c6:	b2da      	uxtb	r2, r3
 80011c8:	4b32      	ldr	r3, [pc, #200]	; (8001294 <main+0x240>)
 80011ca:	701a      	strb	r2, [r3, #0]
					if(1==Error_counter || 2==Error_counter){
 80011cc:	4b31      	ldr	r3, [pc, #196]	; (8001294 <main+0x240>)
 80011ce:	781b      	ldrb	r3, [r3, #0]
 80011d0:	2b01      	cmp	r3, #1
 80011d2:	d003      	beq.n	80011dc <main+0x188>
 80011d4:	4b2f      	ldr	r3, [pc, #188]	; (8001294 <main+0x240>)
 80011d6:	781b      	ldrb	r3, [r3, #0]
 80011d8:	2b02      	cmp	r3, #2
 80011da:	d104      	bne.n	80011e6 <main+0x192>
						MUSART_u8Send_Byte(USART1,(u8 *)'N');
 80011dc:	214e      	movs	r1, #78	; 0x4e
 80011de:	2001      	movs	r0, #1
 80011e0:	f7ff fea2 	bl	8000f28 <MUSART_u8Send_Byte>
 80011e4:	e00c      	b.n	8001200 <main+0x1ac>
					}
					else if(3==Error_counter){
 80011e6:	4b2b      	ldr	r3, [pc, #172]	; (8001294 <main+0x240>)
 80011e8:	781b      	ldrb	r3, [r3, #0]
 80011ea:	2b03      	cmp	r3, #3
 80011ec:	d108      	bne.n	8001200 <main+0x1ac>
						MUSART_u8Send_Byte(USART1,(u8 *)'F');
 80011ee:	2146      	movs	r1, #70	; 0x46
 80011f0:	2001      	movs	r0, #1
 80011f2:	f7ff fe99 	bl	8000f28 <MUSART_u8Send_Byte>
						Error_counter=0;
 80011f6:	4b27      	ldr	r3, [pc, #156]	; (8001294 <main+0x240>)
 80011f8:	2200      	movs	r2, #0
 80011fa:	701a      	strb	r2, [r3, #0]
						Func_CallBack();
 80011fc:	f000 f84e 	bl	800129c <Func_CallBack>
					}
				}
				u8RecCounter = 0 ;
 8001200:	4b20      	ldr	r3, [pc, #128]	; (8001284 <main+0x230>)
 8001202:	2200      	movs	r2, #0
 8001204:	701a      	strb	r2, [r3, #0]
 8001206:	e006      	b.n	8001216 <main+0x1c2>
			}
			else{ u8RecCounter++ ; }
 8001208:	4b1e      	ldr	r3, [pc, #120]	; (8001284 <main+0x230>)
 800120a:	781b      	ldrb	r3, [r3, #0]
 800120c:	b2db      	uxtb	r3, r3
 800120e:	3301      	adds	r3, #1
 8001210:	b2da      	uxtb	r2, r3
 8001212:	4b1c      	ldr	r3, [pc, #112]	; (8001284 <main+0x230>)
 8001214:	701a      	strb	r2, [r3, #0]
			/*End of hex file */
			if( u8RecBuffer[8] == '1' ){
 8001216:	4b1c      	ldr	r3, [pc, #112]	; (8001288 <main+0x234>)
 8001218:	7a1b      	ldrb	r3, [r3, #8]
 800121a:	b2db      	uxtb	r3, r3
 800121c:	2b31      	cmp	r3, #49	; 0x31
 800121e:	d10a      	bne.n	8001236 <main+0x1e2>
				//indicate to successful flashing
				//LED_On(&Led_3);
				MUSART_u8Send_Byte(USART1,(u8 *)'K');
 8001220:	214b      	movs	r1, #75	; 0x4b
 8001222:	2001      	movs	r0, #1
 8001224:	f7ff fe80 	bl	8000f28 <MUSART_u8Send_Byte>
				/*update the flag and jump  */
				CurrantAPP=UpdateAPP;
 8001228:	4b11      	ldr	r3, [pc, #68]	; (8001270 <main+0x21c>)
 800122a:	781b      	ldrb	r3, [r3, #0]
 800122c:	b2da      	uxtb	r2, r3
 800122e:	4b0f      	ldr	r3, [pc, #60]	; (800126c <main+0x218>)
 8001230:	701a      	strb	r2, [r3, #0]
				Func_CallBack();
 8001232:	f000 f833 	bl	800129c <Func_CallBack>
	while( TimeOutFlag == 0 )
 8001236:	4b18      	ldr	r3, [pc, #96]	; (8001298 <main+0x244>)
 8001238:	781b      	ldrb	r3, [r3, #0]
 800123a:	b2db      	uxtb	r3, r3
 800123c:	2b00      	cmp	r3, #0
 800123e:	f43f af63 	beq.w	8001108 <main+0xb4>

#if (BL_communication == CAN_COMM)
	/*for CAN communication*/
#endif

	if(TimeOutFlag == 1){
 8001242:	4b15      	ldr	r3, [pc, #84]	; (8001298 <main+0x244>)
 8001244:	781b      	ldrb	r3, [r3, #0]
 8001246:	b2db      	uxtb	r3, r3
 8001248:	2b01      	cmp	r3, #1
 800124a:	d107      	bne.n	800125c <main+0x208>
		_delay_ms(20);
 800124c:	2014      	movs	r0, #20
 800124e:	f7ff fd81 	bl	8000d54 <_delay_ms>
		Jumper();
 8001252:	f000 f85f 	bl	8001314 <Jumper>
		_delay_ms(20);
 8001256:	2014      	movs	r0, #20
 8001258:	f7ff fd7c 	bl	8000d54 <_delay_ms>
 800125c:	2300      	movs	r3, #0
	}
}
 800125e:	4618      	mov	r0, r3
 8001260:	3708      	adds	r7, #8
 8001262:	46bd      	mov	sp, r7
 8001264:	bd80      	pop	{r7, pc}
 8001266:	bf00      	nop
 8001268:	0800c000 	.word	0x0800c000
 800126c:	2000011c 	.word	0x2000011c
 8001270:	2000011d 	.word	0x2000011d
 8001274:	ffffaaaa 	.word	0xffffaaaa
 8001278:	ffffbbbb 	.word	0xffffbbbb
 800127c:	0800129d 	.word	0x0800129d
 8001280:	00e4e1c0 	.word	0x00e4e1c0
 8001284:	20000184 	.word	0x20000184
 8001288:	20000120 	.word	0x20000120
 800128c:	20000004 	.word	0x20000004
 8001290:	20000005 	.word	0x20000005
 8001294:	20000186 	.word	0x20000186
 8001298:	20000185 	.word	0x20000185

0800129c <Func_CallBack>:

/* USER CODE END 0 */
/* Functions ---------------------------------------------------------*/
void Func_CallBack(void){
 800129c:	b580      	push	{r7, lr}
 800129e:	af00      	add	r7, sp, #0
	TimeOutFlag = 1 ;
 80012a0:	4b16      	ldr	r3, [pc, #88]	; (80012fc <Func_CallBack+0x60>)
 80012a2:	2201      	movs	r2, #1
 80012a4:	701a      	strb	r2, [r3, #0]
	/*update the flag sector and be ready to jump */
	switch(CurrantAPP)
 80012a6:	4b16      	ldr	r3, [pc, #88]	; (8001300 <Func_CallBack+0x64>)
 80012a8:	781b      	ldrb	r3, [r3, #0]
 80012aa:	b2db      	uxtb	r3, r3
 80012ac:	2b02      	cmp	r3, #2
 80012ae:	d018      	beq.n	80012e2 <Func_CallBack+0x46>
 80012b0:	2b02      	cmp	r3, #2
 80012b2:	dc21      	bgt.n	80012f8 <Func_CallBack+0x5c>
 80012b4:	2b00      	cmp	r3, #0
 80012b6:	d002      	beq.n	80012be <Func_CallBack+0x22>
 80012b8:	2b01      	cmp	r3, #1
 80012ba:	d007      	beq.n	80012cc <Func_CallBack+0x30>
		MSTK_voidStopInterval();
		MFMI_voidSectorErase(SECTOR_3);
		MFMI_voidFlashWrite(APP_FLAG_ADD,&APP_2,1);
		break;
	}
}
 80012bc:	e01c      	b.n	80012f8 <Func_CallBack+0x5c>
		TimeOutFlag = 0;
 80012be:	4b0f      	ldr	r3, [pc, #60]	; (80012fc <Func_CallBack+0x60>)
 80012c0:	2200      	movs	r2, #0
 80012c2:	701a      	strb	r2, [r3, #0]
		MSTK_voidReSetInterval((u32)15000000);
 80012c4:	480f      	ldr	r0, [pc, #60]	; (8001304 <Func_CallBack+0x68>)
 80012c6:	f7ff fced 	bl	8000ca4 <MSTK_voidReSetInterval>
		break;
 80012ca:	e015      	b.n	80012f8 <Func_CallBack+0x5c>
		MSTK_voidStopInterval();
 80012cc:	f7ff fcd4 	bl	8000c78 <MSTK_voidStopInterval>
		MFMI_voidSectorErase(SECTOR_3);
 80012d0:	2003      	movs	r0, #3
 80012d2:	f7ff f9bf 	bl	8000654 <MFMI_voidSectorErase>
		MFMI_voidFlashWrite(APP_FLAG_ADD,&APP_1,1);
 80012d6:	2201      	movs	r2, #1
 80012d8:	490b      	ldr	r1, [pc, #44]	; (8001308 <Func_CallBack+0x6c>)
 80012da:	480c      	ldr	r0, [pc, #48]	; (800130c <Func_CallBack+0x70>)
 80012dc:	f7ff fa0e 	bl	80006fc <MFMI_voidFlashWrite>
		break;
 80012e0:	e00a      	b.n	80012f8 <Func_CallBack+0x5c>
		MSTK_voidStopInterval();
 80012e2:	f7ff fcc9 	bl	8000c78 <MSTK_voidStopInterval>
		MFMI_voidSectorErase(SECTOR_3);
 80012e6:	2003      	movs	r0, #3
 80012e8:	f7ff f9b4 	bl	8000654 <MFMI_voidSectorErase>
		MFMI_voidFlashWrite(APP_FLAG_ADD,&APP_2,1);
 80012ec:	2201      	movs	r2, #1
 80012ee:	4908      	ldr	r1, [pc, #32]	; (8001310 <Func_CallBack+0x74>)
 80012f0:	4806      	ldr	r0, [pc, #24]	; (800130c <Func_CallBack+0x70>)
 80012f2:	f7ff fa03 	bl	80006fc <MFMI_voidFlashWrite>
		break;
 80012f6:	bf00      	nop
}
 80012f8:	bf00      	nop
 80012fa:	bd80      	pop	{r7, pc}
 80012fc:	20000185 	.word	0x20000185
 8001300:	2000011c 	.word	0x2000011c
 8001304:	00e4e1c0 	.word	0x00e4e1c0
 8001308:	20000000 	.word	0x20000000
 800130c:	0800c000 	.word	0x0800c000
 8001310:	20000002 	.word	0x20000002

08001314 <Jumper>:

void Jumper(void){
 8001314:	b580      	push	{r7, lr}
 8001316:	af00      	add	r7, sp, #0
	switch(CurrantAPP)
 8001318:	4b0f      	ldr	r3, [pc, #60]	; (8001358 <Jumper+0x44>)
 800131a:	781b      	ldrb	r3, [r3, #0]
 800131c:	b2db      	uxtb	r3, r3
 800131e:	2b02      	cmp	r3, #2
 8001320:	d00e      	beq.n	8001340 <Jumper+0x2c>
 8001322:	2b02      	cmp	r3, #2
 8001324:	dc15      	bgt.n	8001352 <Jumper+0x3e>
 8001326:	2b00      	cmp	r3, #0
 8001328:	d012      	beq.n	8001350 <Jumper+0x3c>
 800132a:	2b01      	cmp	r3, #1
 800132c:	d000      	beq.n	8001330 <Jumper+0x1c>
		Disables();
		BL_voidJumpToAPP_2();
		_delay_ms(20);
		break;
	}
}
 800132e:	e010      	b.n	8001352 <Jumper+0x3e>
		Disables();
 8001330:	f000 f814 	bl	800135c <Disables>
		BL_voidJumpToAPP_1();
 8001334:	f7fe ff4e 	bl	80001d4 <BL_voidJumpToAPP_1>
		_delay_ms(20);
 8001338:	2014      	movs	r0, #20
 800133a:	f7ff fd0b 	bl	8000d54 <_delay_ms>
		break;
 800133e:	e008      	b.n	8001352 <Jumper+0x3e>
		Disables();
 8001340:	f000 f80c 	bl	800135c <Disables>
		BL_voidJumpToAPP_2();
 8001344:	f7fe ff5e 	bl	8000204 <BL_voidJumpToAPP_2>
		_delay_ms(20);
 8001348:	2014      	movs	r0, #20
 800134a:	f7ff fd03 	bl	8000d54 <_delay_ms>
		break;
 800134e:	e000      	b.n	8001352 <Jumper+0x3e>
		break;
 8001350:	bf00      	nop
}
 8001352:	bf00      	nop
 8001354:	bd80      	pop	{r7, pc}
 8001356:	bf00      	nop
 8001358:	2000011c 	.word	0x2000011c

0800135c <Disables>:

void Disables (void){
 800135c:	b580      	push	{r7, lr}
 800135e:	af00      	add	r7, sp, #0
	/*turn off BootLoader LEDs */
	//LED_On(&Led_0);
	/*disable peripherals */
	//MRCC_voidDisablePeripheralClock(AHB1,GPIOC_PORT);
	MUSART_voidDisable(USART1);
 8001360:	2001      	movs	r0, #1
 8001362:	f7ff fdb3 	bl	8000ecc <MUSART_voidDisable>
	MRCC_voidDisablePeripheralClock(APB2,PERIPHERAL_EN_USART1);
 8001366:	2104      	movs	r1, #4
 8001368:	2003      	movs	r0, #3
 800136a:	f7ff fbd7 	bl	8000b1c <MRCC_voidDisablePeripheralClock>
}
 800136e:	bf00      	nop
 8001370:	bd80      	pop	{r7, pc}
	...

08001374 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8001374:	480d      	ldr	r0, [pc, #52]	; (80013ac <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8001376:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8001378:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800137c:	480c      	ldr	r0, [pc, #48]	; (80013b0 <LoopForever+0x6>)
  ldr r1, =_edata
 800137e:	490d      	ldr	r1, [pc, #52]	; (80013b4 <LoopForever+0xa>)
  ldr r2, =_sidata
 8001380:	4a0d      	ldr	r2, [pc, #52]	; (80013b8 <LoopForever+0xe>)
  movs r3, #0
 8001382:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001384:	e002      	b.n	800138c <LoopCopyDataInit>

08001386 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001386:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001388:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800138a:	3304      	adds	r3, #4

0800138c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800138c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800138e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001390:	d3f9      	bcc.n	8001386 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001392:	4a0a      	ldr	r2, [pc, #40]	; (80013bc <LoopForever+0x12>)
  ldr r4, =_ebss
 8001394:	4c0a      	ldr	r4, [pc, #40]	; (80013c0 <LoopForever+0x16>)
  movs r3, #0
 8001396:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001398:	e001      	b.n	800139e <LoopFillZerobss>

0800139a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800139a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800139c:	3204      	adds	r2, #4

0800139e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800139e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80013a0:	d3fb      	bcc.n	800139a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80013a2:	f000 f811 	bl	80013c8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80013a6:	f7ff fe55 	bl	8001054 <main>

080013aa <LoopForever>:

LoopForever:
  b LoopForever
 80013aa:	e7fe      	b.n	80013aa <LoopForever>
  ldr   r0, =_estack
 80013ac:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 80013b0:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80013b4:	20000008 	.word	0x20000008
  ldr r2, =_sidata
 80013b8:	08001430 	.word	0x08001430
  ldr r2, =_sbss
 80013bc:	20000008 	.word	0x20000008
  ldr r4, =_ebss
 80013c0:	20000188 	.word	0x20000188

080013c4 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80013c4:	e7fe      	b.n	80013c4 <ADC_IRQHandler>
	...

080013c8 <__libc_init_array>:
 80013c8:	b570      	push	{r4, r5, r6, lr}
 80013ca:	4d0d      	ldr	r5, [pc, #52]	; (8001400 <__libc_init_array+0x38>)
 80013cc:	4c0d      	ldr	r4, [pc, #52]	; (8001404 <__libc_init_array+0x3c>)
 80013ce:	1b64      	subs	r4, r4, r5
 80013d0:	10a4      	asrs	r4, r4, #2
 80013d2:	2600      	movs	r6, #0
 80013d4:	42a6      	cmp	r6, r4
 80013d6:	d109      	bne.n	80013ec <__libc_init_array+0x24>
 80013d8:	4d0b      	ldr	r5, [pc, #44]	; (8001408 <__libc_init_array+0x40>)
 80013da:	4c0c      	ldr	r4, [pc, #48]	; (800140c <__libc_init_array+0x44>)
 80013dc:	f000 f818 	bl	8001410 <_init>
 80013e0:	1b64      	subs	r4, r4, r5
 80013e2:	10a4      	asrs	r4, r4, #2
 80013e4:	2600      	movs	r6, #0
 80013e6:	42a6      	cmp	r6, r4
 80013e8:	d105      	bne.n	80013f6 <__libc_init_array+0x2e>
 80013ea:	bd70      	pop	{r4, r5, r6, pc}
 80013ec:	f855 3b04 	ldr.w	r3, [r5], #4
 80013f0:	4798      	blx	r3
 80013f2:	3601      	adds	r6, #1
 80013f4:	e7ee      	b.n	80013d4 <__libc_init_array+0xc>
 80013f6:	f855 3b04 	ldr.w	r3, [r5], #4
 80013fa:	4798      	blx	r3
 80013fc:	3601      	adds	r6, #1
 80013fe:	e7f2      	b.n	80013e6 <__libc_init_array+0x1e>
 8001400:	08001428 	.word	0x08001428
 8001404:	08001428 	.word	0x08001428
 8001408:	08001428 	.word	0x08001428
 800140c:	0800142c 	.word	0x0800142c

08001410 <_init>:
 8001410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001412:	bf00      	nop
 8001414:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001416:	bc08      	pop	{r3}
 8001418:	469e      	mov	lr, r3
 800141a:	4770      	bx	lr

0800141c <_fini>:
 800141c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800141e:	bf00      	nop
 8001420:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001422:	bc08      	pop	{r3}
 8001424:	469e      	mov	lr, r3
 8001426:	4770      	bx	lr
